{$IFNDEF SCRIPT_CHAIN}
  {$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
  {$I SRL/osr.simba}
  {$I WaspLib/osr.simba}

begin
  Login.PlayerIndex     := 0;
  AntibanEnabled        := True; //Enables Most Antiban
  BreaksEnabled         := True; //Enables Short Breaks
  SleepEnabled          := True; //Enables Sleep Breaks
  RemoteInputEnabled    := True; //Enables Remote Input
  ProgressReportEnabled := True; //Enables Graphical Progress Report
  ScriptDebugEnabled    := False; //Enables Script Debugging
end;
{$ENDIF}

type
  ERSGlassItem = (BEER, LANTERN, LAMP, VIAL,
                  FISHBOWL, ORB, LENS, BULB, BEST);

var
  CurrentGlass: ERSGlassItem = ERSGlassItem.BEST;

type
  EBlowerState = (
    HOVER_BANK,
    OPEN_BANK,
    WITHDRAW_TOOL,
    WITHDRAW_MATERIAL,
    DEPOSIT_PRODUCT,
    DEPOSIT_RANDOM_ITEM,

    OPEN_COLLECT,
    HANDLE_COLLECT,
    CLOSE_INTERFACE,

    DO_GLASS,
    HANDLE_MAKE,
    WAIT_GLASS,

    LEVEL_UP,
    CLOSE_CONTEXT,

    END_SCRIPT
  );

  TBlower = record(TBaseBankScript)
    State: EBlowerState;

    Tool: TRSBankWithdrawItem;
    Material: TRSBankWithdrawItem;
    Product: TRSBankDepositItem;
    Blowing: Boolean;
    CurrentLevel: Int32;
    UseBestItem: Boolean;
    ItemChanged: Boolean;
  end;


procedure TAntiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.CRAFTING, ERSSkill.TOTAL];
  Antiban.MinZoom := 15;
  Antiban.MaxZoom := 85;
end;

procedure TBlower.SetupProduct();
var
  CurrentLevelItem: ERSGlassItem;
begin
  case Self.CurrentLevel of
    1..3:   CurrentLevelItem := ERSGlassItem.BEER;
    4..11:  CurrentLevelItem := ERSGlassItem.LANTERN;
    12..32: CurrentLevelItem := ERSGlassItem.LAMP;
    33..41: CurrentLevelItem := ERSGlassItem.VIAL;
    42..45: CurrentLevelItem := ERSGlassItem.FISHBOWL;
    46..48: CurrentLevelItem := ERSGlassItem.ORB;
    49..86: CurrentLevelItem := ERSGlassItem.LENS;
    else    CurrentLevelItem := ERSGlassItem.BULB;
  end;

  if CurrentLevelItem <> CurrentGlass then
  begin
    CurrentGlass := CurrentLevelItem;
    Self.ItemChanged := True;
  end;
end;

procedure TBlower.SetupItems;
var
  ProductCost: Int32;
  X_Number: Int32;
begin
  if not Self.ItemChanged then Exit;

  Self.Tool := ['GlassSelf.Blowing pipe', 1, False];
  if SRL.Dice(70) then X_Number := BANK_WITHDRAW_ALL
  else X_Number := Random(27, 9999);
  Self.Material := ['Molten glass', X_Number, False];

  case CurrentGlass of
    ERSGlassItem.BEER:     Self.Product := ['Beer glass', X_Number];
    ERSGlassItem.LANTERN:  Self.Product := ['Empty candle lantern', X_Number];
    ERSGlassItem.LAMP:     Self.Product := ['Empty oil lamp', X_Number];
    ERSGlassItem.VIAL:     Self.Product := ['Vial', X_Number];
    ERSGlassItem.FISHBOWL: Self.Product := ['Empty fishbowl', X_Number];
    ERSGlassItem.ORB:      Self.Product := ['Unpowered orb', X_Number];
    ERSGlassItem.LENS:     Self.Product := ['Lantern lens', X_Number];
    ERSGlassItem.BULB:     Self.Product := ['Empty light orb', X_Number];
  end;

  Self.ExtraInfo := 'Self.Blowing item: ' + Self.Product.Item + '.';
  ProductCost := ItemData.GetAverage(Self.Material.Item);

  Self.ActionProfit := (
    ItemData.GetAverage(Self.Product.Item) -
    ProductCost
  );

  Self.ItemChanged := False;
end;

procedure TBlower.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.Name := 'Glassblower';

  inherited;
  Self.SetupWLBanks();

  if ScriptDebugEnabled then
    DebugObjectArray += Self.ScriptBank;

  Self.UseBestItem := CurrentGlass = ERSGlassItem.Best;
  Self.ItemChanged := True;

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  Self.CurrentLevel := Stats.GetCurrentLevel(ERSSkill.CRAFTING);
end;



function TBlower.HasRandomItem: Boolean;
var
  Slots: TIntegerArray;
  UsedSlots: TIntegerArray := Inventory.GetUsedSlots;
begin
  Inventory.FindItem(Self.Tool.Item, Slots);
  Inventory.FindItem(Self.Material.Item, Slots);

  Result := Length(Slots) <> Length(UsedSlots);
end;

function TBlower.CountItem: Int32;
begin
  if (Result := Inventory.CountItemStack(Self.Product.Item)) = 0 then
    Result := Inventory.CountItem(Self.Product.Item);
end;


function TBlower.Withdraw(Item: TRSBankWithdrawItem): Boolean;
var
  UseQuantityButton: Boolean := Item.Quantity <> 1;
  InvCount: Int32 := Inventory.Count();
begin
  if Result := Bank.WithdrawItem(Self.BankTab, Item, UseQuantityButton) then
    WaitUntil(Inventory.Count() > InvCount, 100, 3000);

  if Self.BankEmpty := (not Result and not Bank.ContainsItem(Self.BankTab, Item)) then
    if Self.CollectEmpty and Self.CollectTimer.IsFinished() then
      Self.CollectEmpty := False;
end;

function TBlower.DepositExtraItems: Boolean;
var
  Slots, DepositSlots: TIntegerArray;
  i: Int32;
begin
  if Self.Tool.Quantity = 1 then
    Inventory.FindItem(Self.Tool.Item, Slots);

  DepositSlots := Slots.Difference(Inventory.GetUsedSlots);

  repeat
    if Result := Bank.DepositSlot([DepositSlots[i], BANK_DEPOSIT_ALL], True) then
      WaitUntil(not Inventory.IsSlotUsed(DepositSlots[i]), 100, 2000);
    DepositSlots := Slots.Difference(Inventory.GetUsedSlots);
  until Result := (DepositSlots = []);
end;

function TBlower.Deposit: Boolean;
var
  ItemCount: Int32 := Self.CountItem;
begin
  if Result := Bank.DepositItem(Self.BankTab, Self.Product, True) then
    if WaitUntil(Self.CountItem = 0, 100, 3000) then
      Self.TotalActions += ItemCount;
end;

function TBlower.HandleCollectBox: Boolean;
var
  Slots: TIntegerArray;
begin
  if CollectBox.FindItems([Self.Tool.Item, Self.Material.Item], Slots) then
  begin
    if Result := Self.CollectEmpty := CollectBox.CollectToBank then
      WaitUntil(not CollectBox.FindItems([Self.Tool.Item, Self.Material.Item], Slots), 50, 2000);
    Self.BankEmpty := not Self.CollectEmpty;
  end
  else
    Self.CollectEmpty := True;

  Self.CollectTimer.Restart();
end;


function TBlower.DoGlass: Boolean;
begin
  if SRL.Dice(50) then
    Result := Inventory.Use(Self.Tool.Item, Self.Material.Item)
  else
    Result := Inventory.Use(Self.Material.Item, Self.Tool.Item);

  if Result then Make.IsOpen(2000);
end;


function TRSMake.SetQuantity(Amount: Int32): Boolean; override;
const
  ENABLED_COLOR = $FFFFFF;
var
  Button: TRSButton;
  Buttons: TRSButtonArray;
begin
  if Amount <> MAKE_QUANTITY_ALL then
    Exit(inherited);

  Buttons := Self.GetQuantityButtons();

  if Buttons = [] then
    Exit;

  Button := Buttons[High(Buttons)];

  if SRL.CountColor(ENABLED_COLOR, Button.Bounds) > 0 then
    Exit(True);

  Exit(Button.Click);
end;


function TBlower.HandleMake: Boolean;
var
  MakeStringArray: TStringArray;
  ItemIndex: Int32;
  i: Int32;
begin
  MakeStringArray := [
    'Beer glass', 'Candle lantern', 'Oil lamp', 'Vial', 'Fishbowl',
    'Unpowered staff orb', 'Lantern lens', 'Light orb'
  ];

  for i := Ord(Low(ERSGlassItem)) to Ord(High(ERSGlassItem)) do
    if CurrentGlass = ERSGlassItem(i) then
    begin
      ItemIndex := i;
      Break;
    end;

  Self.Blowing := Result := Make.Select(ItemIndex, MAKE_QUANTITY_ALL, SRL.Dice(98.5));
  if Result then WaitUntil(not Make.IsOpen, 50, 2000);
end;


function TBlower.WaitBlowing: Boolean;
begin
  if Self.Blowing then
    Result := Self.Blowing := Inventory.ContainsItem(Self.Material.Item) and XPBar.WaitXP(2000)
  else
    Result := Self.Blowing := XPBar.WaitXP(2000);
end;


function TBlower.GetState(): EBlowerState;
begin
  if WL.Activity.IsFinished() then
    Exit(EBlowerState.END_SCRIPT);

  if XPBar.EarnedXP() then
    Exit(EBlowerState.WAIT_GLASS);

  if Chat.LeveledUp() then
  begin
    Self.Blowing := False;
    Exit(EBlowerState.LEVEL_UP);
  end;

  if Make.IsOpen() then
    Exit(EBlowerState.HANDLE_MAKE);

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if Inventory.ContainsItem(Self.Product.Item) then
        Exit(EBlowerState.DEPOSIT_PRODUCT);

      if Self.HasRandomItem then
        Exit(EBlowerState.DEPOSIT_RANDOM_ITEM);

      if Self.BankEmpty or Inventory.FindAllItems([Self.Tool.Item, Self.Material.Item]) then
        Exit(EBlowerState.CLOSE_INTERFACE);

      if not Inventory.ContainsItem(Self.Tool.Item) then
        Exit(EBlowerState.WITHDRAW_TOOL);

      if not Inventory.ContainsItem(Self.Material.Item) then
        Exit(EBlowerState.WITHDRAW_MATERIAL);
    end;

    if CollectBox.IsOpen() then
    begin
      if Self.CollectEmpty then
        Exit(EBlowerState.CLOSE_INTERFACE);

      Exit(EBlowerState.HANDLE_COLLECT);
    end;

    Exit(EBlowerState.CLOSE_INTERFACE);
  end;

  if Inventory.FindAllItems([Self.Tool.Item, Self.Material.Item]) then
  begin
    if Self.Blowing then
      Exit(EBlowerState.WAIT_GLASS);

    Exit(EBlowerState.DO_GLASS);
  end;

  if Self.BankEmpty and Self.CollectEmpty then
    Exit(EBlowerState.END_SCRIPT);

  if Self.BankEmpty then
    Exit(EBlowerState.OPEN_COLLECT);

  Exit(EBlowerState.OPEN_BANK);
end;

function TBlower.Terminate(): Boolean; override;
begin
  if inherited then
    for 0 to 3 do
      if Result := Bank.WithdrawItem(Self.BankTab, [Self.Product.Item, BANK_WITHDRAW_ALL, True], True) then
        Break;
end;

procedure TBlower.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  repeat
    if Self.UseBestItem then
      Self.SetupProduct();

    Self.SetupItems;

    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));
    

    case Self.State of
      EBlowerState.OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      EBlowerState.WITHDRAW_TOOL: Self.Withdraw(Self.Tool);
      EBlowerState.WITHDRAW_MATERIAL: Self.Withdraw(Self.Material);
      EBlowerState.DEPOSIT_PRODUCT: Self.Deposit();
      EBlowerState.DEPOSIT_RANDOM_ITEM: Self.DepositExtraItems();

      EBlowerState.OPEN_COLLECT: CollectBox.WalkOpen(Self.ScriptBank);
      EBlowerState.HANDLE_COLLECT: Self.HandleCollectBox();
      EBlowerState.CLOSE_INTERFACE: MainScreen.CloseInterface();

      EBlowerState.DO_GLASS: Self.DoGlass;
      EBlowerState.HANDLE_MAKE: Self.HandleMake;
      EBlowerState.WAIT_GLASS: Self.WaitBlowing;

      EBlowerState.LEVEL_UP: Chat.HandleLevelUp();
      EBlowerState.CLOSE_CONTEXT: ChooseOption.Close();

      EBlowerState.END_SCRIPT: Break;
    end;

    Self.DoAntiban();
  until Self.ShouldStop();

  if not Self.Terminate() then
    TerminateScript(Self.Name + ' didn''t terminate properly. Stopping execution.');
end;

var
  Blower: TBlower;

function TRSChat.HandleLevelUp(Chance: Double = BioHash): Boolean; override;
begin
  Result := inherited(Chance);

  Blower.CurrentLevel += 1;
end;

type
  TBlowerConfig = record(TScriptForm)
    GlassSelector: TLabeledCombobox;
  end;

procedure TBlowerConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  CurrentGlass := ERSGlassItem(Self.GlassSelector.Combobox.getItemIndex());
end;

procedure TBlowerConfig.Setup(UseFood, UsePrayer, UseBank: Boolean); override;
begin
  inherited;

  with Self.GlassSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Glass item:');
    SetLeft(5);  
    SetTop(35);
    SetWidth(200);
    Combobox.setStyle(csDropDownList);
    AddItem('Beer glass');
    AddItem('Candle lantern');
    AddItem('Oil lamp');
    AddItem('Vial');
    AddItem('Fishbowl');
    AddItem('Unpowered orb');
    AddItem('Lantern lens');
    AddItem('Light orb');
    AddItem('Best available');
    Combobox.setItemIndex(Ord(CurrentGlass));
  end;

  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TBlowerConfig.Run(); override;
begin
  Self.Setup(False, False, True);

  inherited;
end;

var
  BlowerConfig: TBlowerConfig;

{$IFNDEF SCRIPT_CHAIN}
begin
  {$IFDEF SCRIPT_GUI}
  Sync(@BlowerConfig.Run);
  {$ENDIF}
  Blower.Run(MaxActions, MaxTime);
end.
{$ENDIF}
