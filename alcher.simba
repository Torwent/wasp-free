{$IFNDEF SCRIPT_CHAIN}
  {$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
  {$I WaspLib/osr.simba}
begin
  Login.PlayerIndex := 0; //Type "WLSettings." below to open auto-completion and see extra settings you can set.
end;
{$ENDIF}

var
  CustomItem: TRSItem := 'noted Rune 2h sword';
  AlchSpell: ERSSpell := ERSSpell.HIGH_LEVEL_ALCHEMY;
  LossProtection: Boolean := True;

type
  EAlcherState = (
    OPEN_BANK,
    WITHDRAW_NATS,
    WITHDRAW_MONEY,

    OPEN_COLLECT,
    HANDLE_COLLECT,

    CLOSE_INTERFACE,

    OPEN_MAGIC_TAB,
    CHOOSE_SPELL,

    OPEN_INV_TAB,
    CHOOSE_ITEM,
    DESELECT_ITEM,
    HANDLE_WARNING,
    WALK_ALCH,

    CLOSE_CONTEXT,

    END_SCRIPT1,
    END_SCRIPT2
  );

  TAlcher = record(TBaseBankScript)
    State: EAlcherState;
    AlchItem: TRSItem;
    InVarrock: Boolean;
    InGE: Boolean;
  end;

const
  VARROCK_BOUNDS: TPointArray = [
    [7941, 2831], [7941, 2363], [8337, 2370], [8341, 2837]
  ];

procedure Antiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.MAGIC, ERSSkill.TOTAL];
  Antiban.MinZoom := 10;
  Antiban.MaxZoom := 90;
end;

procedure TAlcher.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.Name := 'Alcher';

  inherited;

  Self.RSW.Setup(GRAND_EXCHANGE_MAP);
  Self.ScriptBank := RSObjects.GEBank;

  RSAction.AlchItemArray += CustomItem;

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if not Magic.IsSpellBook(ERSSpellBook.STANDARD) then
    Self.Fatal('Not on Standard Spell Book');

  Self.InVarrock := Self.RSW.InPoly(VARROCK_BOUNDS);
end;


procedure TAlcher.SetupAlchItems();
var
  Item: TRSItem;
  Slot: Int32;
  ItemString: String;
begin
  if not Inventory.Open() and not Inventory.SetSelectedItem(-1) then
    Exit;

  for Item in RSAction.AlchItemArray do
  begin
    if Inventory.FindItem(Item, Slot) then
    begin
      ItemString := ToStr(Item);

      Writeln('Found possible item to alch: ', ItemString + '.');

      if ItemString.Contains('noted ') then
        ItemString := ItemString.After('noted ');

      Self.ActionProfit := ItemData.GetHighAlchProfit(ItemString);
      Writeln('Profit per alch: ', Self.ActionProfit, '.');

      if not LossProtection or (Self.ActionProfit > -350) then //350 gp threshold to account for price fluctuations.
      begin
        Self.ExtraInfo := ' Current Item: ' +  ItemString + ' for ' + ToStr(Self.ActionProfit) + ' each alch.';
        Self.AlchItem := Item;
        Exit;
      end;

      Writeln('Item is not profitable');
    end;
  end;

  TerminateScript('Can''t find items that are worth alching');
end;


function TAlcher.Withdraw(Item: TRSItem): Boolean;
begin
  Result := Bank.WithdrawItem(Self.BankTab, [Item, BANK_WITHDRAW_ALL, False], True);

  if Self.BankEmpty := ((not Result and Bank.IsOpen) and
                    not Bank.ContainsItem(Self.BankTab, Item)) then
    if Self.CollectEmpty and Self.CollectTimer.IsFinished() then
      Self.CollectEmpty := False;
end;

function TAlcher.HandleCollectBox(): Boolean;
var
  ItemArray: TRSItemArray;
begin
  ItemArray += 'Coins';
  ItemArray += 'Nature rune';

  if CollectBox.FindItems(ItemArray) then
  begin
    if Result := Self.CollectEmpty := CollectBox.CollectToBank then
      WaitUntil(not CollectBox.FindItems(ItemArray), 100, 3000);
    Self.BankEmpty := not Self.CollectEmpty;
  end
  else Self.CollectEmpty := True;

  Self.CollectTimer.Restart();
end;



function TAlcher.ChooseSpell(): Boolean;
begin
  if not Magic.IsOpen() and not Magic.CanActivate(AlchSpell) then
    Exit;
  Result := Magic.CastSpell(AlchSpell);
end;

function TAlcher.MoveItem(): Boolean;
var
  Slot: Int32;
begin
  if Inventory.FindItem(Self.AlchItem, Slot) and (Slot = 11) then
    Exit;

  Result := Inventory.Drag(Slot, 11);
end;

function TAlcher.ChooseItem(): Boolean;
var
  Slot: Int32;
  Slots: TIntegerArray;
begin
  if ToStr(Self.AlchItem) = '' then
    Self.SetupAlchItems();

  if Inventory.FindItem(Self.AlchItem, Slot) then
  begin
    if (Slot <> 11) and Inventory.ItemIsStackable(Self.AlchItem) then
    begin
      if ChooseOption.Open() then
        ChooseOption.Select('Cancel');
      Self.MoveItem();
      Exit(False);
    end;

    if SRL.Dice(99.95) and Inventory.ClickSlot(Slot) then
    begin
      if WaitUntil(Magic.IsOpen, 50, SRL.TruncatedGauss(1200, 2000)) then
      begin
        WL.Activity.Restart();
        Self.TotalActions += 1;
        Self.TotalProfit += Self.ActionProfit;

        Wait(2800, 3000);
        Exit(True);
      end;

      Wait(600, 800);
    end
    else
    begin
      Slots := Inventory.GetEmptySlots;
      Inventory.MouseSlot(Inventory.RandomSlotNearby(Slot, Slots), MOUSE_LEFT);
      Exit(False);
    end;
  end;
end;

function TAlcher.HandleWarning(): Boolean;
begin
  if Chat.HasContinue then
    Chat.ClickContinue();
  Chat.ClickOption('Cancel the', False);

  if not Magic.Open() then
    Exit;

  if Magic.MouseSpell(AlchSpell, MOUSE_RIGHT) and ChooseOption.IsOpen() then
    ChooseOption.Select('Warnings');

  WaitUntil(Chat.HasContinue, 50, 2000);
  Chat.ClickContinue();
  WaitUntil(Chat.ClickOption('Set value', False), 50, 3000);
  Wait(2000);
  Result := Chat.AnswerQuery('Set value threshold for', '50000', 1000);
  WaitUntil(Chat.HasContinue, 50, 2000);
  Chat.ClickContinue();
  WaitUntil(Chat.ClickOption('Cancel', False), 50, 3000);
  Wait(2000);
end;


function TAlcher.Terminate(): Boolean; override;
begin
  Result := False;
end;


function TAlcher.GetState(): EAlcherState;
begin
  if WL.Activity.IsFinished() then
    Exit(EAlcherState.END_SCRIPT1);
  if ChooseOption.IsOpen() then
    Exit(EAlcherState.CLOSE_CONTEXT);

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if not Inventory.ContainsItem('Nature rune') then
        Exit(EAlcherState.WITHDRAW_NATS);

      if not Inventory.ContainsItem('Coins') then
        Exit(EAlcherState.WITHDRAW_MONEY);

      Exit(EAlcherState.CLOSE_INTERFACE);
    end;

    if CollectBox.IsOpen() then
    begin
      if Self.CollectEmpty then
        Exit(EAlcherState.CLOSE_INTERFACE);
      Exit(EAlcherState.HANDLE_COLLECT);
    end;

    Exit(EAlcherState.CLOSE_INTERFACE);
  end;

  if Self.InVarrock and not Self.InGE then
  begin
    Self.InGE := Self.RSW.AtTile(Self.ScriptBank.TileArray, 30);
    if not Self.InGE then
      Exit(EAlcherState.WALK_ALCH);
  end;

  if Chat.HasContinue then
    Exit(EAlcherState.HANDLE_WARNING);

  if Magic.IsOpen() then
  begin
    if Magic.IsSpellSelected(AlchSpell) then
      Exit(EAlcherState.OPEN_INV_TAB);

    if not Magic.CanActivate(AlchSpell) and
       not Inventory.ContainsItem('Nature rune') then
    begin
      if Self.BankEmpty and Self.CollectEmpty then
        Exit(EAlcherState.END_SCRIPT2);

      if Self.BankEmpty then
        Exit(EAlcherState.OPEN_COLLECT);

      Exit(EAlcherState.OPEN_BANK);
    end;

    Exit(EAlcherState.CHOOSE_SPELL);
  end;

  if Inventory.IsOpen() then
  begin
    if ToStr(Self.AlchItem) = '' then
      Self.SetupAlchItems();

    if not Inventory.ContainsItem(Self.AlchItem) then
    begin
      if Inventory.GetSelectedSlot > -1 then
        Exit(EAlcherState.DESELECT_ITEM);

      Exit(EAlcherState.END_SCRIPT2);
    end;
      
    if MainScreen.IsUpText('Alchemy ->') then
      Exit(EAlcherState.CHOOSE_ITEM);
  end;

  Exit(EAlcherState.OPEN_MAGIC_TAB);
end;


procedure TAlcher.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));

    case Self.State of
      EAlcherState.WALK_ALCH: Self.InGe := Self.RSW.WebWalk(Self.ScriptBank.TileArray, 10, 0.2);

      EAlcherState.OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      EAlcherState.WITHDRAW_NATS: Self.Withdraw('Nature rune');
      EAlcherState.WITHDRAW_MONEY: Self.Withdraw('Coins');

      EAlcherState.OPEN_COLLECT: CollectBox.WalkOpen(Self.ScriptBank);
      EAlcherState.HANDLE_COLLECT: Self.HandleCollectBox();
      EAlcherState.CLOSE_INTERFACE: MainScreen.CloseInterface();

      EAlcherState.CHOOSE_SPELL: Self.ChooseSpell();
      EAlcherState.CHOOSE_ITEM: Self.ChooseItem();
      EAlcherState.OPEN_MAGIC_TAB: Magic.Open();
      EAlcherState.OPEN_INV_TAB: Inventory.Open();
      EAlcherState.HANDLE_WARNING: Self.HandleWarning();
      EAlcherState.DESELECT_ITEM: Inventory.SetSelectedSlot(-1);
      EAlcherState.CLOSE_CONTEXT: ChooseOption.Close();

      EAlcherState.END_SCRIPT1, EAlcherState.END_SCRIPT2:
        Break;
    end;

    Self.DoAntiban();
  until Self.ShouldStop();

  if not Self.Terminate() then
    Self.Fatal('Didn''t terminate properly. Stopping execution.');
end;

var
  Alcher: TAlcher;

type
  TAlcherConfig = record(TScriptForm)
    AlchSelector: TLabeledCombobox;
    IgnoreProfit: TCheckbox;
    CustomItemSelector: TLabeledEdit;
  end;

procedure TAlcherConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  case Self.AlchSelector.Combobox.getItemIndex() of
    0: AlchSpell := ERSSpell.HIGH_LEVEL_ALCHEMY;
    1: AlchSpell := ERSSpell.LOW_LEVEL_ALCHEMY;
  end;

  LossProtection := Self.IgnoreProfit.IsChecked;
  CustomItem := Self.CustomItemSelector.getText();
end;

procedure TAlcherConfig.Setup(); override;
begin
  inherited;

  UpdateFormSize(Self.Form, Self.Form.GetWidth(), Self.Form.GetHeight() + 50);

  with Self.AlchSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Alchemy spell:');
    SetLeft(5);  
    SetTop(35);
    SetWidth(200);
    Combobox.setStyle(csDropDownList);
    Combobox.getItems.Add('High alchemy');
    Combobox.getItems.Add('Low alchemy');
    Combobox.setItemIndex(0);
  end;

  with Self.IgnoreProfit do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Prevent loss:');
    SetLeft(Self.AlchSelector.GetLeft() + Self.AlchSelector.GetWidth() + 20);
    SetTop(Self.AlchSelector.GetTop() + 20);
    SetEnabled(LossProtection);
  end;

  with Self.CustomItemSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Custom item to alch:');
    SetLeft(5);  
    SetTop(Self.AlchSelector.GetTop() + Self.AlchSelector.GetHeight());
    SetWidth(200);
    SetText(ToStr(CustomItem));
  end;

  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TAlcherConfig.Run(); override;
begin
  Self.Setup();

  inherited;
end;

var
  AlcherConfig: TAlcherConfig;

{$IFNDEF SCRIPT_CHAIN}
begin
  {$IFDEF SCRIPT_GUI}
  Sync(@AlcherConfig.Run);
  {$ENDIF}
  Alcher.Run(MaxActions, MaxTime);
end.
{$ENDIF}
