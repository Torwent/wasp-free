{$IFNDEF SCRIPT_CHAIN}
  {$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
  {$I WaspLib/osr.simba}

begin
  Login.PlayerIndex     := 0;
  AntibanEnabled        := True; //Enables Most Antiban
  BreaksEnabled         := True; //Enables Short Breaks
  SleepEnabled          := True; //Enables Sleep Breaks
  RemoteInputEnabled    := True; //Enables Remote Input
  ProgressReportEnabled := True; //Enables Graphical Progress Report
  ScriptDebugEnabled    := False; //Enables Script Debugging
end;
{$ENDIF}

type
  ERSBarType = (
    BRONZE, IRON, SILVER, STEEL, GOLD, MITHRIL, ADAMANT, RUNITE, MOLTEN_GLASS
  );

  ERSFurnace = (
    EDGEVILLE_FURNACE, FALADOR_FURNACE
  );

var
  CurrentBarType = ERSBarType.GOLD;
  CurrentFurnace = ERSFurnace.EDGEVILLE_FURNACE;

type
  ESmelterState = (
    HOVER_BANK,
    OPEN_BANK,
    WITHDRAW_MATERIALS,
    DEPOSIT_BAR,
    DEPOSIT_RANDOM_ITEM,

    OPEN_COLLECT,
    HANDLE_COLLECT,

    OPEN_FURNACE,
    SMELT_BAR,
    WAIT_SMELT,

    CLOSE_INTERFACE,

    LEVEL_UP,
    CLOSE_CONTEXT,

    END_SCRIPT,
    OUT_OF_SUPPLIES
  );

  TSmelter = record(TBaseBankScript)
    State: ESmelterState;

    Furnace: TRSObject;

    Ore1: TRSBankWithdrawItem;
    Ore2: TRSBankWithdrawItem;

    Bar: TRSBankDepositItem;
    Materials: TRSItemArray;
    Smelting: Boolean;

    BarAmount: Int32;
    Multiplier: Int32;
  end;


procedure TAntiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.Smithing, ERSSkill.TOTAL];
  Antiban.MinZoom := 0;
  Antiban.MaxZoom := 40;
end;

procedure TSmelter.SetupFurnaces();
begin
  case CurrentFurnace of
    ERSFurnace.EDGEVILLE_FURNACE:
      begin
        Self.RSW.Setup(EDGEVILLE_AND_BARBARIAN_VILLAGE_MAP);
        Self.Furnace := RSObjects.EdgevilleFurnace;
        Self.ScriptBank := RSObjects.EdgevilleBank;
      end;

    ERSFurnace.FALADOR_FURNACE:
      begin
        Self.RSW.Setup(FALADOR_MAP);
        Self.Furnace := RSObjects.FaladorFurnace;
        Self.ScriptBank := RSObjects.FaladorWestBank;
      end;
  end;
end;

procedure TSmelter.SetupItems();
begin
  Self.Bar.Quantity := BANK_DEPOSIT_ALL;

  case CurrentBarType of
    ERSBarType.BRONZE:
      begin
        Self.Bar.Item := 'Bronze Self.Bar';
        Self.Ore1 := ['Copper Self.Ore', 14, False];
        Self.Ore2 := ['Tin Self.Ore', 14, False];
      end;

    ERSBarType.IRON:
      begin
        Self.Bar.Item := 'Iron Self.Bar';
        Self.Ore1 := ['Iron Self.Ore', BANK_WITHDRAW_ALL, False];
      end;

    ERSBarType.SILVER:
      begin
        Self.Bar.Item := 'Silver Self.Bar';
        Self.Ore1 := ['Silver Self.Ore', BANK_WITHDRAW_ALL, False];
      end;

    ERSBarType.STEEL:
      begin
        Self.Bar.Item := 'Steel Self.Bar';
        Self.Ore1 := ['Iron Self.Ore', 9, False];
        Self.Ore2 := ['Coal', 18, False];
      end;

    ERSBarType.GOLD:
      begin
        Self.Bar.Item := 'Gold Self.Bar';
        Self.Ore1 := ['Gold Self.Ore', BANK_WITHDRAW_ALL, False];
      end;

    ERSBarType.MITHRIL:
      begin
        Self.Bar.Item := 'Mithril Self.Bar';
        Self.Ore1 := ['Mithril Self.Ore', 5, False];
        Self.Ore2 := ['Coal', 20, False];
      end;

    ERSBarType.ADAMANT:
      begin
        Self.Bar.Item := 'Adamantite Self.Bar';
        Self.Ore1 := ['Adamantite Self.Ore', 4, False];
        Self.Ore2 := ['Coal', 24, False];
      end;

    ERSBarType.RUNITE:
      begin
        Self.Bar.Item := 'Runite Self.Bar';
        Self.Ore1 := ['Runite Self.Ore', 3, False];
        Self.Ore2 := ['Coal', 27, False];
      end;

    ERSBarType.MOLTEN_GLASS:
      begin
        Self.Bar.Item := 'Molten glass';
        Self.Ore1 := ['Soda ash', 14, False];
        Self.Ore2 := ['Bucket of sand', 14, False];
        Antiban.Skills := [ERSSkill.CRAFTING, ERSSkill.TOTAL];
      end;
  end;

  Self.Materials += Self.Ore1.Item;
  Self.ActionProfit := (ItemData.GetAverage(Self.Bar.Item)) -
                  (ItemData.GetAverage(Self.Ore1.Item) * Self.Ore1.Quantity);

  if Self.Ore2 <> [] then
  begin
    Self.ActionProfit -= (ItemData.GetAverage(Self.Ore2.Item) * Round(Self.Ore2.Quantity / Self.Ore1.Quantity));
    Self.Materials += Self.Ore2.Item;
  end;
end;


procedure TSmelter.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.Name := 'Smelter';

  inherited;

  Self.SetupFurnaces();
  Self.SetupItems();

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if ScriptDebugEnabled then
  begin
    DebugObjectArray += Self.ScriptBank;
    DebugObjectArray += Self.Furnace;
  end;
end;


function TSmelter.Withdraw(): Boolean;
var
  InvCount: Int32;
  Item: TRSBankWithdrawItem;
  Find1, Find2: Boolean;
begin
  Find1 := Inventory.ContainsItem(Self.Ore1.Item);
  Find2 := (Self.Ore2 = []) or Inventory.ContainsItem(Self.Ore2.Item);

  if Find1 then
  begin
    if Find2 then
      Exit;
    Item := Self.Ore2;
    Item.Quantity := Self.Ore1.Quantity;
  end
  else if Find2 or (Self.Ore1.Quantity > Self.Ore2.Quantity) or
          ((Self.Ore1.Quantity = Self.Ore2.Quantity) and Antiban.BioDice()) then
  begin
    Item := Self.Ore1
    if Self.Ore2 <> [] then
      Item.Quantity := Self.Ore2.Quantity;
  end
  else
    Item := Self.Ore2;

  InvCount := Inventory.Count();
  if Result := Bank.WithdrawItem(Self.BankTab, Item, True) then
    WaitUntil(Inventory.Count() > InvCount, 100, 3000);

  if Self.BankEmpty := ((not Result and Bank.IsOpen()) and
                    not Bank.ContainsItem(Self.BankTab, Item)) then
    if Self.CollectEmpty and Self.CollectTimer.IsFinished() then
      Self.CollectEmpty := False;
end;

function TSmelter.Deposit(): Boolean;
var
  ItemCount: Int32 := Inventory.Count();
begin
  if Result := Bank.DepositAll then
    if WaitUntil(Inventory.Count() = 0, 100, 3000) then
      Self.TotalActions += ItemCount;
end;

function TSmelter.HandleCollectBox(): Boolean;
begin
  if not CollectBox.IsOpen() then Exit;

  if CollectBox.FindItems(Self.Materials) then
  begin
    if Result := Self.CollectEmpty := CollectBox.CollectToBank then
      WaitUntil(not CollectBox.FindItems(Self.Materials), 100, 3000);
    Self.BankEmpty := not Self.CollectEmpty;
  end
  else Self.CollectEmpty := True;

  Self.CollectTimer.Restart();
end;


function TSmelter.OpenFurnace(): Boolean;
begin
  if Self.Furnace.WalkSelectOption(['Smelt']) then
  begin
    Minimap.WaitPlayerMoving(300, 10000);
    Result := Make.IsOpen(8000);
  end;
end;


function TSmelter.SmeltBar(): Boolean;
begin
  if not Inventory.FindAllItems(Self.Materials) then
    Exit;

  if Result := Make.Select(ToStr(Self.Bar.Item), MAKE_QUANTITY_ALL, Antiban.BioDice(EBioBehavior.KEYBOARD_CHAT_CHANCE)) then
    Self.Smelting := XPBar.WaitXP(3500);
end;

function TSmelter.IsMakingItem(WaitTime: Int32 = 3200): Boolean;
var
  ItemCount: Int32 := Inventory.CountItem(Self.Bar.Item);
begin
  if Result := WaitUntil(ItemCount < Inventory.CountItem(Self.Bar.Item), 100, WaitTime) then
    WL.Activity.Restart();
end;

function TSmelter.WaitSmelt(): Boolean;
begin
  if Self.Smelting then
    Result := Self.Smelting := (Inventory.FindAllItems(Self.Materials) and Self.IsMakingItem)
  else
    Result := Self.Smelting := Self.IsMakingItem();

  if Result then
    WL.Activity.Restart();
end;


function TSmelter.GetState(): ESmelterState;
begin
  if WL.Activity.IsFinished() then
    Exit(ESmelterState.END_SCRIPT);

  if Chat.LeveledUp() then
  begin
    Self.Smelting := False;
    Exit(ESmelterState.LEVEL_UP);
  end;

  if MainScreen.HasInterface() then
  begin
    Self.HoveringBank := False;
    if Bank.IsOpen() then
    begin
      if Inventory.ContainsItem(Self.Bar.Item) then
        Exit(ESmelterState.DEPOSIT_BAR);

      if Inventory.HasRandomItem(Self.Materials) then
        Exit(ESmelterState.DEPOSIT_RANDOM_ITEM);

      if not Self.BankEmpty and not Inventory.FindAllItems(Self.Materials) then
        Exit(ESmelterState.WITHDRAW_MATERIALS);
    end;

    if not Self.CollectEmpty and CollectBox.IsOpen() then
      Exit(ESmelterState.HANDLE_COLLECT);

    Exit(ESmelterState.CLOSE_INTERFACE);
  end;

  if Inventory.FindAllItems(Self.Materials) then
  begin
    if Self.Smelting then
    begin
      if not Self.HoveringBank then
      begin
        Self.CountItemsLeft(Self.Ore1.Item);

        if Self.ShouldHover then
          Exit(ESmelterState.HOVER_BANK);
      end;

      Exit(ESmelterState.WAIT_SMELT);
    end;

    if Make.IsOpen() then
      Exit(ESmelterState.SMELT_BAR);

    Exit(ESmelterState.OPEN_FURNACE);
  end;

  if Self.BankEmpty then
  begin
    if Self.CollectEmpty then
      Exit(ESmelterState.OUT_OF_SUPPLIES);

    Exit(ESmelterState.OPEN_COLLECT);
  end;

  if Self.BankEmpty then
    Exit(ESmelterState.OPEN_COLLECT);

  Exit(ESmelterState.OPEN_BANK);
end;

function TSmelter.Terminate(): Boolean; override;
begin
  Result := inherited;
  if Result then
    for 0 to 5 do
      if Result := Bank.WithdrawItem(Self.BankTab, [Self.Bar.Item, BANK_WITHDRAW_ALL, True], True) then
        Break;
end;

procedure TSmelter.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  repeat
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));

    case Self.State of
      ESmelterState.HOVER_BANK: Self.Hover();
      ESmelterState.OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      ESmelterState.WITHDRAW_MATERIALS: Self.Withdraw();
      ESmelterState.DEPOSIT_BAR: Self.Deposit();
      ESmelterState.DEPOSIT_RANDOM_ITEM: Bank.DepositAllBut(Self.BankTab, Self.Materials);

      ESmelterState.OPEN_COLLECT: CollectBox.WalkOpen(Self.ScriptBank);
      ESmelterState.HANDLE_COLLECT: Self.HandleCollectBox();

      ESmelterState.OPEN_FURNACE: Self.OpenFurnace();
      ESmelterState.SMELT_BAR: Self.SmeltBar();
      ESmelterState.WAIT_SMELT: Self.WaitSmelt();

      ESmelterState.CLOSE_INTERFACE: MainScreen.CloseInterface();
      ESmelterState.CLOSE_CONTEXT: ChooseOption.Close();
      ESmelterState.LEVEL_UP: Chat.HandleLevelUp();

      ESmelterState.END_SCRIPT, ESmelterState.OUT_OF_SUPPLIES: Break;
    end;

    Self.DoAntiban();
  until Self.ShouldStop();

  if not Self.Terminate() then
    TerminateScript(Self.Name + ' didn''t terminate properly. Stopping execution.');
end;

var
  Smither: TSmelter;

type
  TSmelterConfig = record(TScriptForm)
    BarTypeSelector: TLabeledCombobox;
    FurnaceSelector: TLabeledCombobox;
  end;

procedure TSmelterConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  CurrentBarType := ERSBarType(Self.BarTypeSelector.getItemIndex());
  CurrentFurnace := ERSFurnace(Self.FurnaceSelector.getItemIndex());
end;

procedure TSmelterConfig.Setup(); override;
begin
  inherited;

  with Self.BarTypeSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Bar type:');
    SetLeft(5);  
    SetTop(35);
    SetWidth(200);
    SetStyle(csDropDownList);
    AddItem('Bronze');
    AddItem('Iron');
    AddItem('Silver');
    AddItem('Steel');
    AddItem('Gold');
    AddItem('Mithril');
    AddItem('Adamantite');
    AddItem('Runite');
    AddItem('Molten glass');
    SetItemIndex(Ord(CurrentBarType));
  end;

  with Self.FurnaceSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Furnace:');
    SetLeft(Self.BarTypeSelector.GetLeft() + Self.BarTypeSelector.GetWidth() + 5);
    SetTop(Self.BarTypeSelector.GetTop());
    SetWidth(200);
    SetStyle(csDropDownList);
    AddItem('Edgeville');
    AddItem('Falador');
    SetItemIndex(Ord(CurrentFurnace));
  end;

  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TSmelterConfig.Run(); override;
begin
  Self.Setup();

  inherited;
end;

var SmitherConfig: TSmelterConfig;

{$IFNDEF SCRIPT_CHAIN}
begin
  {$IFDEF SCRIPT_GUI}
  Sync(@SmitherConfig.Run);
  {$ENDIF}
  Smither.Run(MaxActions, MaxTime);
end.
{$ENDIF}
