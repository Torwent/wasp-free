{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I SRL/osr.simba}
{$I WaspLib/osr.simba}

begin
  Login.PlayerIndex     := 0;
  AntibanEnabled        := True; //Enables Most Antiban
  BreaksEnabled         := True; //Enables Short Breaks
  SleepEnabled          := True; //Enables Sleep Breaks
  RemoteInputEnabled    := True; //Enables Remote Input
  ProgressReportEnabled := True; //Enables Graphical Progress Report
  ScriptDebugEnabled    := False; //Enables Script Debugging
end;

var
  FoodAmount: Int32 := 5;
  NeckAmount: Int32 := 2;
  NextHeal: Int32;

type
  EThieverState = (
    OPEN_BANK,
    DEPOSIT_LOOT,
    WITHDRAW_FOOD,
    WITHDRAW_NECKLACES,
    CLOSE_INTERFACE,

    OPEN_CHAT,
    CHANGE_CHAT_FILTER,

    WALK_TO_NPC,
    EQUIP_ROGUE,
    DROP_ITEMS,

    PICKPOCKET,
    OPEN_POUCH,

    EAT_FOOD,
    EQUIP_NECKLACE,
    CHECK_NECKLACE,
    CLOSE_CONTEXT,

    END_SCRIPT
  );

  TThiever = record(TBaseBankScript)
    //init variables (to be set while the script is initiates)
    State: EThieverState;

    ArdyKnight: TRSNPC;

    CoinPouch: TRSItem;
    Necklace: TRSItem;
    ValuableItem: TRSItem;

    LootArray: TRSItemArray;
    StackableArray: TRSItemArray;
    DropArray: TRSItemArray;
    RogueEquipment: TRSItemArray;

    NeckTimer: TCountDown;

    //run variables (to be used while the script is running)
    HasNeck: Boolean;
    FreshNeck: Boolean;

    CoinPouchLimit: Int32;
    MaxHit: Int32;
  end;

function TRSChooseOption.Select(Text: TStringArray; MouseAction: Int32 = MOUSE_LEFT; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean; override;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if not Self.Open() then
    Exit;

  Wait(0, 1000 - Round(1000*BioHash), wdLeft);

  Choices := Self.GetOptions;

  for I := 0 to High(Choices) do
    for J := 0 to High(Text) do
      if (CaseSensitive and (Text[J] in Choices[I].Text)) or
         ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
      begin
        Self.Select(Choices[I], MouseAction);
        Exit(True);
      end;

  if CloseIfNotFound then
  begin
    WaitEx(350 - Round(350*BioHash), 50);
    Self.Close();
  end;

end;


procedure TAntiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.THIEVING, ERSSkill.TOTAL];
  Antiban.MinZoom := 30;
  Antiban.MaxZoom := 50;
end;

procedure TThiever.SetupNPC();
begin
  FoodHandler.Amount := FoodAmount;

  Self.RSW.Setup('x5723y3038');
  ArdyKnight := RSNPCs.KnightOfArdougne;
  Self.ScriptBank := RSObjects.ArdougneSouthBank;

  ArdyKnight.Filter.MinimapDot := False;
  //ArdyKnight.DotFilter.Setup([[5987, 3309], [5987, 3297], [6028, 3297], [6028, 3330], [5987, 3330]], True);

  LootArray += CoinPouch;
  LootArray += 'Coins';

  StackableArray := LootArray;
  MaxHit := 3;
  Self.ActionProfit := 100;


  DropArray += 'Jug';
  DropArray += 'Pie dish';

  StackableArray += Necklace; //not stackable but this array is used to not bank items
  StackableArray += 'Cosmic rune';

  ArdyKnight.Filter.Walker := False;
end;

procedure TThiever.CheckRogueEquipment();
var
  ProfitMultiplier: Double;
  Item: TRSItem;
begin
  if Inventory.Open() then
  begin
    if Inventory.FindItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue mask';
    end;

    if Inventory.FindItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue top';
    end;

    if Inventory.FindItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue trousers';
    end;

    if Inventory.FindItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue gloves';
    end;

    if Inventory.FindItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue boots';
    end;

    //This are not part of rogue equipment but are useful while thieving
    if Inventory.FindItem('Thieving cape') then
      RogueEquipment += 'Thieving cape'
    else if Inventory.FindItem('Thieving cape(t)') then
      RogueEquipment += 'Thieving cape(t)';

    //Lava staves for shadow veil spell
    if Inventory.FindItem('Lava battlestaff') then
      RogueEquipment += 'Lava battlestaff'
    else if Inventory.FindItem('Mystic lava staff') then
      RogueEquipment += 'Mystic lava staff'
    else if Inventory.FindItem(21200) then
      RogueEquipment += 21200;
  end;

  if Equipment.Open() then
  begin
    if Equipment.FindItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue mask';
    end;

    if Equipment.FindItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue top';
    end;

    if Equipment.FindItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue trousers';
    end;

    if Equipment.FindItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue gloves';
    end;

    if Equipment.FindItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      RogueEquipment += 'Rogue boots';
    end;


    //This are not part of rogue equipment but are useful while thieving
    if Equipment.FindItem('Thieving cape') then
      RogueEquipment += 'Thieving cape'
    else if Equipment.FindItem('Thieving cape(t)') then
      RogueEquipment += 'Thieving cape(t)';

    //Lava staves for shadow veil spell
    if Equipment.FindItem('Lava battlestaff') then
      RogueEquipment += 'Lava battlestaff'
    else if Equipment.FindItem('Mystic lava staff') then
      RogueEquipment += 'Mystic lava staff'
    else if Equipment.FindItem(21200) then
      RogueEquipment += 21200;

  end;

  Self.ActionProfit += Round(Self.ActionProfit * ProfitMultiplier);

  for Item in RogueEquipment do
    StackableArray += Item; //Adding RogueEquipment to the non banking item list
end;

procedure TThiever.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Name    := 'Ardougne Knight Pickpocketer';

  inherited;

  CoinPouch := 'Coin pouch';
  Necklace := 'Dodgy necklace';

  Self.SetupNPC;

  //NeckTimer to recheck necklace in case the script messes up.
  NeckTimer.Init(140000);

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if Antiban.BioDice then
    Options.SetNPCAttackOption(ERSAttackOption.HIDDEN)
  else
    Options.SetNPCAttackOption(ERSAttackOption.ALWAYS_RIGHT_CLICK);

  Self.CheckRogueEquipment;
  HasNeck := Equipment.FindItem(Necklace);

  if (FoodHandler.Amount + NeckAmount + 2) >= 26 then
      FoodHandler.Amount := 26 - NeckAmount;

  if ScriptDebugEnabled then
  begin
    DebugObjectArray += Self.ScriptBank;
    DebugNPCArray += @ArdyKnight;
  end;
end;



function TRSInventory.HoverItems(Items: TRSItemArray): Boolean;
var
  Item: TRSItem;
  Slot: Int32;
begin
  for Item in Items do
    if Result := Self.FindItem(Item, Slot) then Break;

  if Result then Mouse.Move(Self.GetSlotBox(Slot));
end;

function TRSInventory.ClickItems(Items: TRSItemArray; Option: String = ''): Boolean;
begin
  if Self.HoverItems(Items) then
  begin
    if (Option <> '') then Result := ChooseOption.Select(Option)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      Result := True;
    end;
  end;
end;

function TRSInventory.CountItems(Items: TRSItemArray): Int32;
var
  Item: TRSItem;
begin
  for Item in Items do Result += Self.CountItem(Item);
end;



function TThiever.HasRogue: Boolean;
begin
  Result := Inventory.FindItems(RogueEquipment);
end;

function TThiever.EquipRogue: Boolean;
var
  Item: TRSItem;
begin
  for Item in RogueEquipment do
    if Inventory.ClickItem(Item) then
      Wait(200, 300);

  if Inventory.ClickItem(21200) then
    Wait(200, 300);

  Result := not Self.HasRogue and not Inventory.FindItem('Lava battlestaff');
end;


function TThiever.HasDepositItems: Boolean;
var
  Slots: TIntegerArray;
  UsedSlots: TIntegerArray := Inventory.GetUsedSlots;
begin
  Inventory.FindItems(StackableArray, Slots);

  Result := Length(Slots) <> Length(UsedSlots);
end;

function TThiever.HasSpace: Boolean;
begin            //we need at least 2 spaces always.
      Result := (Inventory.CountEmptySlots() >= 2) or
                (Inventory.FindItem(CoinPouch) and
                 Inventory.FindItem('Coins')
                 and not Inventory.FindItems(DropArray));
end;


function TThiever.IsLowHP: Boolean;
var
  CurrentHP: Int32 := Minimap.GetHPLevel;
begin
  if NextHeal < 1 then
    NextHeal := Round(Antiban.GetUniqueNumber(MaxHit * 8));

  NextHeal += Random(-3, 3);

  Result := (CurrentHP <= NextHeal) or (CurrentHP <= MaxHit);
end;

function TThiever.IsPouchFull: Boolean;
begin
  if CoinPouchLimit < 1 then
    CoinPouchLimit := SRL.TruncatedGauss(28, 1);
  Result := Inventory.CountItemStack(CoinPouch) >= CoinPouchLimit;
end;


function TThiever.CheckFailed(StartingHP: Int32): Boolean;
var
  HasHitSplat: Boolean;
begin
  HasHitSplat := MainScreen.FindHitsplats(MainScreen.GetPlayerBox) <> [];

  Result := (Minimap.GetHPLevel < StartingHP) or HasHitSplat;

  if Result then
    Self.Open()CoinPouch;
end;

function TThiever.NecklaceExpired: Boolean;
begin
  Result := Chat.FindMessage('crumbles', [CHAT_COLOR_LIGHT_RED]);
  HasNeck := not Result;
end;

function TThiever.Dodged: Boolean;
begin
  Result := Chat.FindMessage('dodgy');
end;


function TThiever.Open()CoinPouch: Boolean;
var
  PouchCount: Int32;
begin
  PouchCount := Inventory.CountItemStack(CoinPouch);
  if Inventory.ClickItem(CoinPouch) then
  begin
    Wait(300);
    Result := WaitUntil(not Inventory.FindItem(CoinPouch), 100, 1200);
  end;

  if Result then
  begin
    CoinPouchLimit := SRL.TruncatedGauss(28, 1);
    Self.TotalActions += PouchCount;
    WL.Activity.Restart();
  end;

  if not Result then
    Self.Open()CoinPouch;
end;

function TThiever.Heal: Boolean;
begin
  repeat
    if not Inventory.Consume(FOOD_CONSUMABLE) then
      Exit;

    Wait(300, 500);
  until Result := (Minimap.GetHPPercent >= (50 + Antiban.GetUniqueNumber(20)));

  if Result then
    NextHeal := Round(Antiban.GetUniqueNumber(MaxHit * 7));
end;

function TThiever.EquipNeck: Boolean;
begin
  if Result := Inventory.ClickItem(Necklace) then Wait(300, 400);

  FreshNeck := HasNeck := Result;
end;

function TThiever.CheckNeck: Boolean;
begin
  Result := HasNeck := Equipment.FindItem(Necklace);

  NeckTimer.Restart(Random(-30000, 60000));
end;


function TThiever.PickNPC: Boolean;
var
  Slot: Int32 := Inventory.GetSelectedSlot;
  CurrentHP: Int32 := Minimap.GetHPLevel;
begin
  if Slot > -1 then Inventory.ClickSlot(Slot);

  if Result := ArdyKnight.SelectOption(['Pick', 'pocket']) then
  begin
    Minimap.WaitPlayerMoving(300, 10000);

    RSObjects.Gravestone.TileArray.Insert(Self.RSW.GetMyPos, 0);
    if Length(RSObjects.Gravestone.TileArray) > 4 then
      RSObjects.Gravestone.TileArray.Pop;

    if not Self.NecklaceExpired then
      FreshNeck := False;

    Self.CheckFailed(CurrentHP);
    WL.Activity.Restart();
  end;
end;

function TThiever.Deposit: Boolean;
var
  ItemCount: Int32;
begin
  if ToStr(ValuableItem) <> '' then
    ItemCount := Inventory.CountItem(ValuableItem);
  Result := Bank.DepositAllBut(Self.BankTab, StackableArray);
end;

function TThiever.Withdraw(Item: TRSItem; Quantity: Int32): Boolean;
var
  ItemCount: Int32 := Inventory.CountItem(Item);
  QuantityNeeded: Int32 := Quantity - ItemCount;
  InvCount: Int32;
begin
  InvCount := Inventory.Count();
  if Result := Bank.WithdrawItem(Self.BankTab, [Item, QuantityNeeded, False], False) then
    WaitUntil(Inventory.Count() > InvCount, 100, 3000);

  if not Result and (Item = Necklace) then
    NeckAmount := 0;
end;

function TThiever.WithdrawAny(Items: TRSItemArray; Quantity: Int32): Boolean;
var
  Item: TRSItem;
  ItemCount: Int32 := Inventory.CountItems(Items);
  QuantityNeeded: Int32 := Quantity - ItemCount;
  InvCount: Int32;
begin
  for Item in Items do
    if Bank.FindItem(Item) then Exit(Self.Withdraw(Item, Quantity));

  for Item in Items do
  begin
    if Self.BankTab = -1 then
      Self.BankTab := Bank.FindItemTab(Item);

    InvCount := Inventory.Count();
    if Result := Bank.WithdrawItem(Self.BankTab, [Item, QuantityNeeded, False], False) then
    begin
      WaitUntil(Inventory.Count() > InvCount, 100, 3000);
      Exit;
    end;
  end;

  FoodHandler.Amount := 0;
end;

(*
function TThiever.LootGrave: Boolean;
begin
  HasNeck := False;
  FreshNeck := False;
  RedemptionEnabled := False;

  if RSObjects.Gravestone.WalkSelectOption(['Loot']) then
  begin
    Minimap.WaitPlayerMoving(300, 10000);
    Result := WaitUntil(not MainScreen.FindGrave, 100, 10000);
  end;

  if Result then RSObjects.Gravestone.TileArray := [];
end;
 *)
function TThiever.LootGrave: Boolean;
var
  TPA, GraveTPA: TPointArray;
  P: TPoint;
  UpTextFound: Boolean;
begin
  HasNeck := False;
  FreshNeck := False;

  if not Minimap.WaitArrow(TPA, 3000) then
    Exit;

  while not MainScreen.WaitArrow(GraveTPA, 3000) do
  begin
    Mouse.Click(TPA.Grow(6).Random, MOUSE_LEFT);
    Minimap.WaitMoving();
  end;

  if not MainScreen.WaitArrow(GraveTPA, 3000) then
    Exit;

  repeat
    GraveTPA.SortByY(False);
    P := GraveTPA[0];
    P.Y += 5;
    Mouse.Move(P);
    UpTextFound := MainScreen.IsUpText('Grave');
    if not UpTextFound then
      MainScreen.WaitArrow(GraveTPA, 3000);
  until UpTextFound;

  Result := ChooseOption.Select('Loot');

  if Result then RSObjects.Gravestone.TileArray := [];
end;


function TThiever.GetState(): EThieverState;
begin
  if WL.Activity.IsFinished() then
    Exit(END_SCRIPT);

  if ChooseOption.IsOpen() then
    Exit(CLOSE_CONTEXT);

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if Self.HasDepositItems then
        Exit(DEPOSIT_LOOT);
      if Inventory.CountItem(Necklace) < NeckAmount then
        Exit(WITHDRAW_NECKLACES);
      if not Inventory.HasEnoughConsumable(FOOD_CONSUMABLE) then
        Exit(WITHDRAW_FOOD);
    end;

    Exit(CLOSE_INTERFACE);
  end;

  if Self.IsPouchFull then
    Exit(OPEN_POUCH);

  if ChatButtons.GetState(ERSChatButton.GAME_CHAT) <> ERSChatButtonState.ENABLED then
    Exit(CHANGE_CHAT_FILTER);

  if not ChatButtons.IsActive(ERSChatButton.GAME_CHAT) then
    Exit(OPEN_CHAT);

  if NeckTimer.IsFinished() then
    Exit(CHECK_NECKLACE);

  if Self.HasRogue then
    Exit(EQUIP_ROGUE);

  if not Self.HasSpace then
  begin
    if Inventory.FindItems(DropArray) then
      Exit(DROP_ITEMS);
    if Inventory.FindConsumable(FOOD_CONSUMABLE) then
      Exit(EAT_FOOD);

    Exit(OPEN_BANK);
  end;

  if (NeckAmount > 0) and not FreshNeck and (not HasNeck or Self.NecklaceExpired) then
  begin
    if Inventory.FindItem(Necklace) then
      Exit(EQUIP_NECKLACE);

    Exit(OPEN_BANK);
  end;

  if Self.IsLowHP then
  begin
    if Inventory.FindConsumable(FOOD_CONSUMABLE) then
      Exit(EAT_FOOD);

    Exit(OPEN_BANK);
  end;

  if not Self.RSW.AtTile(ArdyKnight.TileArray, 40) then
    Exit(WALK_TO_NPC);

  Exit(PICKPOCKET);
end;

procedure TThiever.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  while not Self.ShouldStop do
  begin
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));
    Self.ExtraInfo := ' FreshNeck: ' + ToStr(FreshNeck) +
                 ',   HasNeck: ' + ToStr(HasNeck) +
                 STR_NEW_LINE +
                  ',   NextHeal: ' + ToStr(NextHeal);
    

    case Self.State of
      OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      DEPOSIT_LOOT: Self.Deposit();
      WITHDRAW_FOOD: Bank.WithdrawConsumable(FOOD_CONSUMABLE);
      WITHDRAW_NECKLACES: Self.Withdraw(Necklace, NeckAmount);
      CLOSE_INTERFACE: MainScreen.CloseInterface();

      OPEN_CHAT: ChatButtons.Open(ERSChatButton.GAME_CHAT);
      CHANGE_CHAT_FILTER: ChatButtons.ChangeState(ERSChatButton.GAME_CHAT, ERSChatButtonState.ENABLED);

      PICKPOCKET: Self.PickNPC;
      OPEN_POUCH: Self.Open()CoinPouch;

      EAT_FOOD: Self.Heal;
      EQUIP_NECKLACE: Self.EquipNeck;
      CHECK_NECKLACE: Self.CheckNeck;
      CLOSE_CONTEXT: ChooseOption.Close();
      DROP_ITEMS: Inventory.ShiftDrop(DropArray, Inventory.RandomPattern);
      WALK_TO_NPC: Self.RSW.WebWalk(ArdyKnight.TileArray, 30, 0.2);
      EQUIP_ROGUE: Self.EquipRogue;

      END_SCRIPT: Break;
    end;

    Self.DoAntiban();
  end;
end;

var
  Thiever: TThiever;

procedure TConsumableManager.Setup(ConsumableType: ERSConsumable); override;
var
  Item: TRSItem;
begin
  inherited;

  if ConsumableType = FOOD_CONSUMABLE then
    for Item in Self.ItemArray do
      if Thiever.StackableArray.Find(Item) < 0 then
        Thiever.StackableArray += Item;
end;

procedure TConsumableManager.SetupNew(ConsumableType: ERSConsumable); override;
var
  Item: TRSItem;
begin
  inherited;

  if ConsumableType = FOOD_CONSUMABLE then
    for Item in Self.ItemArray do
      if Thiever.StackableArray.Find(Item) < 0 then
        Thiever.StackableArray += Item;
end;


function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean; override;
begin
  Result := Self.CountPoints(ConsumableType) >= FoodHandler.Amount;
end;

function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Idx: Int32): Int32; override;
var
  HandlerManager: ^TConsumableManager := GetHandler(ConsumableType);
begin
  if ConsumableType = FOOD_CONSUMABLE then
    Exit(FoodHandler.Amount - Inventory.Count()Consumable(FOOD_CONSUMABLE));

  case HandlerManager^.Handlers[Idx].Amount of
    BANK_WITHDRAW_ALL: Result := BANK_WITHDRAW_ALL;
    BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
    else
      Result := Ceil((HandlerManager^.MinInvPoints - Inventory.Count()Points(ConsumableType)) / HandlerManager^.Handlers[Idx].GetPoints);
  end;
end;

type
  TThieverConfig = record(TScriptForm)
    FoodAmountEdit: TLabeledEdit;
    NeckAmountEdit: TLabeledEdit;
    MinHealthEdit: TLabeledEdit;
  end;

procedure TThieverConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  FoodAmount := StrToInt(FoodAmountEdit.getText());
  NeckAmount := StrToInt(NeckAmountEdit.getText());
  NextHeal := StrToInt(MinHealthEdit.getText());
end;

procedure TThieverConfig.Setup(); override;
begin
  inherited;

  Self.UpdateFormSize(Form.GetWidth(), Form.GetHeight() + 70);

  with FoodAmountEdit do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Food amount:');
    SetLeft(5);  
    SetTop(5);
    SetWidth(80);
    SetText(ToStr(FoodAmount));
  end;

  with NeckAmountEdit do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Necklaces amount:');
    SetLeft(FoodAmountEdit.GetLeft() + FoodAmountEdit.GetWidth() + 30);
    SetTop(FoodAmountEdit.GetTop());
    SetWidth(80);
    SetText(ToStr(NeckAmount));
  end;

  with MinHealthEdit do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Minimum health:');
    SetLeft(NeckAmountEdit.GetLeft() + NeckAmountEdit.GetWidth() + 35);
    SetTop(FoodAmountEdit.GetTop());
    SetWidth(80);
    SetText(ToStr(Round(Antiban.GetUniqueNumber(10 * 8))));
  end;

  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TThieverConfig.Run(); override;
begin
  Self.Setup();

  inherited;
end;

var
  ThieverConfig: TThieverConfig;

begin
  {$IFDEF SCRIPT_GUI}
  Sync(@ThieverConfig.Run);
  {$ENDIF}
  Thiever.Run(MaxActions, MaxTime);
end.
