{$IFNDEF SCRIPT_CHAIN}
  {$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
  {$I SRL/osr.simba}
  {$I WaspLib/osr.simba}

begin
  Login.PlayerIndex     := 0;
  AntibanEnabled        := True; //Enables Most Antiban
  BreaksEnabled         := True; //Enables Short Breaks
  SleepEnabled          := True; //Enables Sleep Breaks
  RemoteInputEnabled    := True; //Enables Remote Input
  ProgressReportEnabled := True; //Enables Graphical Progress Report
  ScriptDebugEnabled    := False; //Enables Script Debugging
end;
{$ENDIF}

const
  GEM_TYPE: TStringArray = [
    'Opal', 'Jade', 'Red topaz',
    'Sapphire', 'Emerald', 'Ruby',
    'Diamond', 'Dragonstone', 'Onyx',
    'Zenyte'
  ];

  JEWELRY_TYPE: TStringArray = [
    'Ring', 'Necklace', 'Bracelet', 'Amulet'
  ];

var
  RegularJewel: TRSItem = 'Ruby necklace';

type
  EEnchanterState = (
    LEVEL_UP,
    CLOSE_CONTEXT,

    OPEN_BANK,
    WITHDRAW_TOOL,
    WITHDRAW_MATERIAL,
    DEPOSIT_PRODUCT,

    OPEN_COLLECT,
    HANDLE_COLLECT,
    CLOSE_INTERFACE,

    OPEN_MAGIC,
    OPEN_INVENTORY,

    CAST_SPELL,
    ENCHANT_JEWEL,
    CANCEL_SPELL,
    WAIT_ENCHANT,

    END_SCRIPT
  );

  TEnchanter = record(TBaseBankScript)
    State: EEnchanterState;

    Spell: ERSSpell;
    CosmicRune: TRSItem;
    EnchantedJewel: TRSItem;
    Enchanting: Boolean;
  end;

procedure TAntiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.MAGIC, ERSSkill.TOTAL];
  Antiban.MinZoom := 15;
  Antiban.MaxZoom := 85;
end;


procedure TEnchanter.SetSpell;
var
  ItemString: String := ToStr(RegularJewel);
begin
  if ItemString.Contains(['Opal', 'Sapphire']) then
    Self.Spell := ERSSpell.LVL1_ENCHANT
  else if ItemString.Contains(['Jade', 'Emerald']) then
    Self.Spell := ERSSpell.LVL2_ENCHANT
  else if ItemString.Contains(['Topaz', 'Ruby']) then
    Self.Spell := ERSSpell.LVL3_ENCHANT
  else if ItemString.Contains('Diamond') then
    Self.Spell := ERSSpell.LVL4_ENCHANT
  else if ItemString.Contains('Dragon') then
    Self.Spell := ERSSpell.LVL5_ENCHANT
  else if ItemString.Contains('Onyx') then
    Self.Spell := ERSSpell.LVL6_ENCHANT
  else if ItemString.Contains('Zenyte') then
    Self.Spell := ERSSpell.LVL7_ENCHANT
end;

procedure TEnchanter.SetEnchantedJewel;
var
  ItemString: String := ToStr(RegularJewel);
begin

  if ItemString.Contains('Opal') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of pursuit'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Dodgy necklace'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Expeditious bracelet'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of bounty';
  end

  else if ItemString.Contains('Jade') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of returning(5)'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Necklace of passage(5)'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Flamtaer bracelet'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of Chemistry';
  end

  else if ItemString.Contains('Topaz') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Efaritay''s aid'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Necklace of faith'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Bracelet of slaughter'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Burning amulet(5)';
  end

  else if ItemString.Contains('Sapphire') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of recoil'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Games necklace(8)'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Bracelet of clay'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of magic';
  end

  else if ItemString.Contains('Emerald') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of dueling(8)'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Binding necklace'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Castle wars bracelet(3)'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of defence';
  end

  else if ItemString.Contains('Ruby') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of forging'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Digsite pendant (5)'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Inoculation bracelet'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of strength';
  end

  else if ItemString.Contains('Diamond') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of life'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Phoenix necklace'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Abyssal bracelet(5)'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of power';
  end

  else if ItemString.Contains('Dragon') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of wealth'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Skills necklace'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Combat bracelet(4)'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of glory(4)';
  end

  else if ItemString.Contains('Onyx') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of stone'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Berserker necklace'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Regen bracelet'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of fury';
  end

  else if ItemString.Contains('Zenyte') then
  begin
    if ItemString.Contains('ring') then
      Self.EnchantedJewel := 'Ring of suffering'
    else if ItemString.Contains('necklace') then
      Self.EnchantedJewel := 'Necklace of anguish'
    else if ItemString.Contains('bracelet') then
      Self.EnchantedJewel := 'Tormented bracelet'
    else if ItemString.Contains('amulet') then
      Self.EnchantedJewel := 'Amulet of torture';
  end;


end;

procedure TEnchanter.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.Name := 'AIO Enchanter';

  inherited;
  Self.SetupWLBanks();

  Self.ExtraInfo := ' Currently Self.Enchanting: ' + RegularJewel + '.';

  Self.CosmicRune := 'Cosmic rune';
  Self.SetSpell;
  Self.SetEnchantedJewel;

  Self.ActionProfit := (
    ItemData.GetAverage(Self.EnchantedJewel) -
    ItemData.GetAverage(Self.CosmicRune) + ItemData.GetAverage(RegularJewel)
  );

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if ScriptDebugEnabled then
    DebugObjectArray += Self.ScriptBank;
end;


function TEnchanter.HasProduct: Boolean
var
  Slots: TIntegerArray;
begin
  Result := Inventory.FindItem(Self.EnchantedJewel, Slots);
end;




function TEnchanter.EnchantJewel: Boolean;
begin
  if Result := Inventory.ClickItem(RegularJewel) then
  begin
    Self.Enchanting := SRL.Dice(20 * BioHash);
    WaitUntil(Magic.IsOpen, 50, 2000);
  end;
end;

function TEnchanter.WaitEnchanting(): Boolean;
begin
  if Self.Enchanting then
    Result := Self.Enchanting := Inventory.ContainsAll([Self.CosmicRune, RegularJewel]) and XPBar.WaitXP(2000)
  else
    Result := Self.Enchanting := XPBar.WaitXP(2000);
end;

function TEnchanter.DeselectSpell: Boolean;
var
  Selected: ERSSpell;
begin
  if Magic.IsOpen() then
  begin
    if (Selected := Magic.GetSelectedSpell) <> ERSSpell.UNKNOWN then
    begin
      Magic.MouseSpell(Selected, MOUSE_LEFT);
      Result := Magic.GetSelectedSpell = ERSSpell.UNKNOWN;
    end;
  end
  else if MainScreen.IsUpText('Cast') then
  begin
    ChooseOption.Open();
    ChooseOption.Select('Cancel');
  end;
end;


function TEnchanter.Withdraw(Item: TRSItem): Boolean;
begin
  Result := Bank.WithdrawItem(Self.BankTab, [Item, BANK_WITHDRAW_ALL, False], True);

  if Result then
    WaitUntil(Inventory.ContainsItem(Item), 100, 3000);

  if Self.BankEmpty := (not Result and not Bank.ContainsItem(Self.BankTab, Item)) then
    if Self.CollectEmpty and Self.CollectTimer.IsFinished() then
      Self.CollectEmpty := False;
end;

function TEnchanter.Deposit: Boolean;
var
  ItemCount: Int32 := Inventory.CountItem(Self.EnchantedJewel);
begin
  if Result := Bank.DepositItem(Self.BankTab, [Self.EnchantedJewel, BANK_DEPOSIT_ALL], True) then
    if WaitUntil(Inventory.CountItem(Self.EnchantedJewel) = 0, 100, 3000) then
      Self.TotalActions += ItemCount;
end;


function TEnchanter.HandleCollectBox: Boolean;
var
  Slots: TIntegerArray;
begin
  if CollectBox.FindItems([RegularJewel, Self.CosmicRune], Slots) then
  begin
    if Result := Self.CollectEmpty := CollectBox.CollectToBank then
      WaitUntil(not CollectBox.FindItems([RegularJewel, Self.CosmicRune], Slots), 100, 3000);
    Self.BankEmpty := not Self.CollectEmpty;
  end
  else
    Self.CollectEmpty := True;

  Self.CollectTimer.Restart();
end;


function TEnchanter.GetState(): EEnchanterState;
begin
  if WL.Activity.IsFinished() then
    Exit(EEnchanterState.END_SCRIPT);

  if Chat.LeveledUp() then
  begin
    Self.Enchanting := False;
    Exit(EEnchanterState.LEVEL_UP);
  end;

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if Self.HasProduct() then
        Exit(EEnchanterState.DEPOSIT_PRODUCT);

      if Self.BankEmpty or Inventory.ContainsAll([Self.CosmicRune, RegularJewel]) then
        Exit(EEnchanterState.CLOSE_INTERFACE);

      if not Inventory.ContainsItem(Self.CosmicRune) then
        Exit(EEnchanterState.WITHDRAW_TOOL);

      if not Inventory.ContainsItem(RegularJewel) then
        Exit(EEnchanterState.WITHDRAW_MATERIAL);
    end;

    if CollectBox.IsOpen() then
    begin
      if Self.CollectEmpty or Inventory.ContainsAll([Self.CosmicRune, RegularJewel]) then
        Exit(EEnchanterState.CLOSE_INTERFACE);
      Exit(EEnchanterState.HANDLE_COLLECT);
    end;

    Exit(EEnchanterState.CLOSE_INTERFACE);
  end;

  if Inventory.IsOpen() then
  begin
    if Inventory.ContainsAll([Self.CosmicRune, RegularJewel]) then
    begin
      if MainScreen.IsUpText('>') then
        Exit(EEnchanterState.ENCHANT_JEWEL);
      if Self.Enchanting then
        Exit(EEnchanterState.WAIT_ENCHANT);
      Exit(EEnchanterState.OPEN_MAGIC);
    end;

    if MainScreen.IsUpText('>') then
      Exit(EEnchanterState.CANCEL_SPELL);

    if Self.BankEmpty and Self.CollectEmpty then
      Exit(EEnchanterState.END_SCRIPT);

    if Self.BankEmpty then
      Exit(EEnchanterState.OPEN_COLLECT);

    Exit(EEnchanterState.OPEN_BANK);
  end;

  if Magic.IsOpen() then
  begin
    if Self.Enchanting or Magic.IsSpellSelected(Self.Spell) then
      Exit(OPEN_INVENTORY);
    Exit(CAST_SPELL);
  end;

  Exit(EEnchanterState.OPEN_MAGIC);
end;

function TEnchanter.Terminate(): Boolean; override;
begin
  if inherited then
    for 0 to 5 do
      if Result := Bank.WithdrawItem(Self.BankTab, [Self.EnchantedJewel, BANK_WITHDRAW_ALL, True], True) then
        Break;
end;

procedure TEnchanter.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  while not Self.ShouldStop do
  begin
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));
    

    case Self.State of
      EEnchanterState.OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      EEnchanterState.WITHDRAW_TOOL: Self.Withdraw(Self.CosmicRune);
      EEnchanterState.WITHDRAW_MATERIAL: Self.Withdraw(RegularJewel);
      EEnchanterState.DEPOSIT_PRODUCT: Self.Deposit();

      EEnchanterState.OPEN_COLLECT: CollectBox.WalkOpen(Self.ScriptBank);
      EEnchanterState.HANDLE_COLLECT: Self.HandleCollectBox();
      EEnchanterState.CLOSE_INTERFACE: MainScreen.CloseInterface();

      EEnchanterState.WAIT_ENCHANT: Self.Enchanting := XPBar.WaitXP(2000);
      EEnchanterState.LEVEL_UP: Chat.HandleLevelUp(SRL.Dice(75));

      EEnchanterState.OPEN_MAGIC: Magic.Open();
      EEnchanterState.OPEN_INVENTORY: Inventory.Open();
      EEnchanterState.CAST_SPELL: Magic.CastSpell(Self.Spell);
      EEnchanterState.ENCHANT_JEWEL: Self.EnchantJewel();
      EEnchanterState.CANCEL_SPELL: Self.DeselectSpell();

      EEnchanterState.END_SCRIPT: Break;
    end;

    Self.DoAntiban();
  end;

  if not Self.Terminate() then
    TerminateScript('aio_enchanter didn''t terminate properly. Stopping execution.');
end;

var
  Enchanter: TEnchanter;

type
  TEnchanterConfig = record(TScriptForm)
    GemSelector: TLabeledCombobox;
    JewelSelector: TLabeledCombobox;
  end;

procedure TEnchanterConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  RegularJewel := Self.GemSelector.getText() + ' ' + Self.JewelSelector.getText().ToLower();
end;

procedure TEnchanterConfig.Setup(UseFood, UsePrayer, UseBank: Boolean); override;
var
  Str: String
begin
  inherited;

  with Self.GemSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Gem type:');
    SetLeft(5);  
    SetTop(35);
    SetWidth(200);
    SetStyle(csDropDownList);
    for Str in GEM_TYPE do
      AddItem(Str);
    SetItemIndex(3);
  end;

  with Self.JewelSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Jewel type:');
    SetLeft(Self.GemSelector.GetLeft() + Self.GemSelector.GetWidth() + 5);
    SetTop(Self.GemSelector.GetTop());
    SetWidth(200);
    SetStyle(csDropDownList);
    for Str in JEWELRY_TYPE do
      AddItem(Str);
    SetItemIndex(0);
  end;

  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TEnchanterConfig.Run(); override;
begin
  Self.Setup(False, False, True);

  inherited;
end;

var
  EnchanterConfig: TEnchanterConfig;

{$IFNDEF SCRIPT_CHAIN}
begin
  {$IFDEF SCRIPT_GUI}
  Sync(@EnchanterConfig.Run);
  {$ENDIF}
  Enchanter.Run(MaxActions, MaxTime);
end.
{$ENDIF}
