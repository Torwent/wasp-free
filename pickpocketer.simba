{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I WaspLib/osr.simba}

begin
  Login.PlayerIndex     := 0;
  AntibanEnabled        := True; //Enables Most Antiban
  BreaksEnabled         := True; //Enables Short Breaks
  SleepEnabled          := True; //Enables Sleep Breaks
  RemoteInputEnabled    := True; //Enables Remote Input
  ProgressReportEnabled := True; //Enables Graphical Progress Report
  ScriptDebugEnabled    := False; //Enables Script Debugging
end;

type
  ENPC = (
    MAN, MASTER_FARMER,
    GUARD, KNIGHT_OF_ARDOUGNE, ELF, TZHAAR_CITY
  );

var
  PickedNPC: ENPC := ENPC.ELF;       //Use one of the above NPCs.
  SuicideMode: Boolean := True;      //Pickpocket until death. Useful if you respawn nearby.
  FoodAmount: Int32 := 5;
  NeckAmount: Int32 := 2;
  NextHeal: Int32;

type
  EThieverState = (
    OPEN_BANK,
    DEPOSIT_LOOT,
    WITHDRAW_FOOD,
    WITHDRAW_NECKLACES,
    CLOSE_INTERFACE,

    OPEN_CHAT,
    CHANGE_CHAT_FILTER,

    WALK_TO_NPC,
    EQUIP_ROGUE,

    CAST_SHADOW_VEIL,
    PICKPOCKET,
    OPEN_POUCH,

    EAT_FOOD,
    EQUIP_NECKLACE,
    CHECK_NECKLACE,
    CLOSE_CONTEXT,

    DROP_ITEMS,

    ENABLE_REDEMPTION,
    LOOT_GRAVE,

    END_SCRIPT
  );

  TThiever = record(TBaseBankScript)
    //init variables (to be set while the script is initiates)
    State: EThieverState;

    UseShadowVeil: Boolean;
    UseRedemption: Boolean;

    CurrentNPC: TRSNPC;

    CoinPouch: TRSItem;
    Necklace: TRSItem;
    ValuableItem: TRSItem;

    LootArray: TRSItemArray;
    StackableArray: TRSItemArray;
    DropArray: TRSItemArray;
    RogueEquipment: TRSItemArray;

    GearAmount: Int32;
    ValuableItemValue: Int32;

    NeckTimer: TCountDown;
    ShadowVeilTimer: TCountDown;
    LasPickPosition: TPoint;

    //run variables (to be used while the script is running)
    RenderDisabled: Boolean;
    HasNeck: Boolean;
    FreshNeck: Boolean;
    RedemptionEnabled: Boolean;

    CoinPouchLimit: Int32;
    NPCMaxHit: Int32;
  end;

function TRSChooseOption.Select(Text: TStringArray; MouseAction: Int32 = MOUSE_LEFT; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean; override;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if not Self.Open() then
    Exit;

  Wait(0, 1000 - Round(1000*BioHash), wdLeft);

  Choices := Self.GetOptions;

  for I := 0 to High(Choices) do
    for J := 0 to High(Text) do
      if (CaseSensitive and (Text[J] in Choices[I].Text)) or
         ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
      begin
        Self.Select(Choices[I], MouseAction);
        Exit(True);
      end;

  if CloseIfNotFound then
  begin
    WaitEx(350 - Round(350*BioHash), 50);
    Self.Close();
  end;

end;


procedure TAntiban.Setup(); override;
begin
  inherited;

  Antiban.Skills := [ERSSkill.THIEVING, ERSSkill.TOTAL];
  Antiban.MinZoom := 30;
  Antiban.MaxZoom := 50;
end;

procedure TThiever.SetupNPC();
begin
  FoodHandler.Amount := FoodAmount;

  case PickedNPC of
    MAN:
      begin
        Self.RSW.Setup(LUMBRIDGE_MAP);
        Self.CurrentNPC := RSNPCs.Man;

        Self.LootArray += Self.CoinPouch;
        Self.LootArray += 'Coins';

        Self.StackableArray := Self.LootArray;

        Self.NPCMaxHit := 1;

        if not SuicideMode then
          SuicideMode := True;

        Self.ActionProfit := 3;
      end;

    MASTER_FARMER:
      begin
        Self.RSW.Setup(DRAYNOR_VILLAGE_MAP);
        Self.CurrentNPC := RSNPCs.MasterFarmer;
        Self.LootArray := [
          'Potato seed', 'Onion seed', 'Cabbage seed', 'Tomato seed',
          'Sweetcorn seed', 'Strawberry seed', 'Watermelon seed',
          'Snape grass seed',

          'Barley seed', 'Hammerstone seed', 'Asgarnian seed', 'Jute seed',
          'Yanillian seed', 'Krandorian seed', 'Wildblood seed',

          'Marigold seed', 'Nasturtium seed', 'Rosemary seed', 'Woad seed',
          'Limpwurt seed',

          'Redberry seed', 'Cadavaberry seed', 'Dwellberry seed',
          'Jangerberry seed', 'Whiteberry seed', 'Poison ivy seed',

          'Ranarr seed',

          'Mushroom spore', 'Belladonna seed', 'Cactus seed', 'Seaweed spore',
          'Potato cactus seed'
        ];

        Self.DropArray := [
          'Potato seed', 'Onion seed', 'Cabbage seed', 'Tomato seed',
          'Sweetcorn seed', 'Strawberry seed', 'Watermelon seed',

          'Barley seed', 'Hammerstone seed', 'Asgarnian seed', 'Jute seed',
          'Yanillian seed', 'Krandorian seed', 'Wildblood seed',

          'Marigold seed', 'Nasturtium seed', 'Rosemary seed', 'Woad seed',
          'Limpwurt seed',

          'Redberry seed', 'Cadavaberry seed', 'Dwellberry seed',
          'Jangerberry seed', 'Whiteberry seed', 'Poison ivy seed',

          'Mushroom spore', 'Belladonna seed', 'Cactus seed',
          'Potato cactus seed'
        ];

        Self.NPCMaxHit := 3;

        Self.ScriptBank := RSObjects.DraynorBank;

        if SuicideMode then
          SuicideMode := False;
      end;

    GUARD:
      begin
        Self.RSW.Setup(FALADOR_MAP);
        Self.CurrentNPC := RSNPCs.Guard;

        Self.LootArray += Self.CoinPouch;
        Self.LootArray += 'Coins';

        Self.StackableArray := Self.LootArray;

        Self.NPCMaxHit := 2;
        Self.ActionProfit := 30;

        Self.ScriptBank := RSObjects.FaladorWestBank;
      end;

    ELF:
      begin
        Self.RSW.Setup(PRIFDDINAS_MAP);
        Self.CurrentNPC := RSNPCs.Elf;
        Self.ScriptBank := RSObjects.PrifddinasBank;

        Self.LootArray := [
          Self.CoinPouch, 'Coins', 'Death rune', 'Jug of wine', 'Nature rune',
          'Fire orb', 'Diamond', 'Gold ore', 'Crystal shards',
          'Enhanced crystal teleport seed'
        ];

        Self.ActionProfit := 560;
        Self.ValuableItem := 'Enhanced crystal teleport seed';
        Self.ValuableItemValue := ItemData.GetAverage(Self.ValuableItem);


        Self.DropArray := ['Gold ore'];

        Self.StackableArray := [Self.CoinPouch, 'Coins', 'Death rune', 'Nature rune',
                           'Crystal shards'];

        Self.NPCMaxHit := 5;
      end;

    TZHAAR_CITY:
      begin
        Self.RSW.Setup(TZHAAR_MAP);
        Self.CurrentNPC := RSNPCs.TzhaarHur;
        Self.LootArray := [
          'Tokkul', 'Uncut sapphire', 'Uncut emerald',
          'Uncut ruby', 'Uncut diamond'
        ];

        Self.StackableArray := Self.LootArray;

        Self.NPCMaxHit := 4;

        Self.ScriptBank := RSObjects.TzhaarBank;

        if SuicideMode then
          SuicideMode := False;
      end;
  end;

  Self.DropArray += 'Jug';
  Self.DropArray += 'Pie dish';

  Self.StackableArray += Self.Necklace; //not stackable but this array is used to not bank items
  Self.StackableArray += 'Cosmic rune';

  Self.CurrentNPC.Filter.Walker := False;
end;

procedure TThiever.CheckRogueEquipment();
var
  ProfitMultiplier: Double;
  Item: TRSItem;
begin
  if Inventory.Open() then
  begin
    if Inventory.ContainsItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue mask';
    end;

    if Inventory.ContainsItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue top';
    end;

    if Inventory.ContainsItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue trousers';
    end;

    if Inventory.ContainsItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue gloves';
    end;

    if Inventory.ContainsItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue boots';
    end;

    //This are not part of rogue equipment but are useful while thieving
    if Inventory.ContainsItem('Thieving cape') then
      Self.RogueEquipment += 'Thieving cape'
    else if Inventory.ContainsItem('Thieving cape(t)') then
      Self.RogueEquipment += 'Thieving cape(t)'
    else if Inventory.ContainsItem('Max cape') then
      Self.RogueEquipment += 'Max cape';

    //Lava staves for shadow veil spell
    if Inventory.ContainsItem('Lava battlestaff') then
      Self.RogueEquipment += 'Lava battlestaff'
    else if Inventory.ContainsItem('Mystic lava staff') then
      Self.RogueEquipment += 'Mystic lava staff'
    else if Inventory.ContainsItem(21200) then
      Self.RogueEquipment += 21200;
  end;

  if Equipment.Open() then
  begin
    if Equipment.ContainsItem('Rogue mask') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue mask';
    end;

    if Equipment.ContainsItem('Rogue top') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue top';
    end;

    if Equipment.ContainsItem('Rogue trousers') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue trousers';
    end;

    if Equipment.ContainsItem('Rogue gloves') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue gloves';
    end;

    if Equipment.ContainsItem('Rogue boots') then
    begin
      ProfitMultiplier += 0.2;
      Self.RogueEquipment += 'Rogue boots';
    end;


    //This are not part of rogue equipment but are useful while thieving
    if Equipment.ContainsItem('Thieving cape') then
      Self.RogueEquipment += 'Thieving cape'
    else if Equipment.ContainsItem('Thieving cape(t)') then
      Self.RogueEquipment += 'Thieving cape(t)';

    //Lava staves for shadow veil spell
    if Equipment.ContainsItem('Lava battlestaff') then
      Self.RogueEquipment += 'Lava battlestaff'
    else if Equipment.ContainsItem('Mystic lava staff') then
      Self.RogueEquipment += 'Mystic lava staff'
    else if Equipment.ContainsItem(21200) then
      Self.RogueEquipment += 21200;

  end;

  Self.GearAmount := Equipment.CountGear;
  if not Equipment.IsSlotUsed(ERSEquipmentButton.AMULET) then
    Self.GearAmount += 1;

  Self.ActionProfit += Round(Self.ActionProfit * ProfitMultiplier);

  for Item in Self.RogueEquipment do
    Self.StackableArray += Item; //Adding Self.RogueEquipment to the non banking item list
end;

procedure TThiever.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.Name := 'Pickpocketer';

  inherited;

  Mouse.Speed := 20;

  Self.UseRedemption := SuicideMode;

  Self.CoinPouch := 'Coin pouch';
  Self.Necklace := 'Dodgy Necklace';

  Self.SetupNPC();

  //Self.NeckTimer to recheck necklace in case the script messes up.
  Self.NeckTimer.Init(140000);

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if Antiban.BioDice() then
    Options.SetNPCAttackOption(ERSAttackOption.HIDDEN)
  else
    Options.SetNPCAttackOption(ERSAttackOption.ALWAYS_RIGHT_CLICK);

  Self.CheckRogueEquipment();
  Self.HasNeck := Equipment.ContainsItem(Self.Necklace);
  if Magic.CanActivate(ERSSpell.SHADOW_VEIL) then
  begin
    Self.UseShadowVeil := True;
    Magic.CastSpell(ERSSpell.SHADOW_VEIL);
    Self.ShadowVeilTimer.Init(1000 * Round(0.6 * Stats.GetCurrentLevel(ERSSkill.MAGIC)));
  end;

  if not SuicideMode and ((FoodHandler.Amount + NeckAmount + 2) >= 26) then
  begin
    if Self.UseShadowVeil then
      FoodHandler.Amount := 26 - NeckAmount - 1
    else
      FoodHandler.Amount := 26 - NeckAmount;
  end
  else if ((FoodHandler.Amount + NeckAmount + 2 + Length(Self.StackableArray)) >= (28 - Length(Self.StackableArray))) then
    FoodHandler.Amount := 28 - NeckAmount - 2 - Length(Self.StackableArray);

  if ScriptDebugEnabled then
  begin
    DebugObjectArray += Self.ScriptBank;
    DebugNPCArray += Self.CurrentNPC;
  end;
end;



function TRSInventory.HoverItems(Items: TRSItemArray): Boolean;
var
  Item: TRSItem;
  Slot: Int32;
begin
  for Item in Items do
    if Result := Self.FindItem(Item, Slot) then Break;

  if Result then Mouse.Move(Self.GetSlotBox(Slot));
end;

function TRSInventory.ClickItems(Items: TRSItemArray; Option: String = ''): Boolean;
begin
  if Self.HoverItems(Items) then
  begin
    if (Option <> '') then Result := ChooseOption.Select(Option)
    else
    begin
      Mouse.Click(MOUSE_LEFT);
      Result := True;
    end;
  end;
end;

function TRSInventory.CountItems(Items: TRSItemArray): Int32;
var
  Item: TRSItem;
begin
  for Item in Items do Result += Self.CountItem(Item);
end;



function TThiever.HasRogue(): Boolean;
begin
  Result := Inventory.ContainsAny(Self.RogueEquipment);
end;

function TThiever.EquipRogue(): Boolean;
var
  Item: TRSItem;
begin
  for Item in Self.RogueEquipment do
    if Inventory.ClickItem(Item) then
      Wait(200, 300);

  if Inventory.ClickItem(21200) then
    Wait(200, 300);

  Result := not Self.HasRogue() and not Inventory.ContainsItem('Lava battlestaff');
end;


function TThiever.HasDepositItems: Boolean;
var
  Slots: TIntegerArray;
  UsedSlots: TIntegerArray := Inventory.GetUsedSlots;
begin
  Inventory.FindItems(Self.StackableArray, Slots);

  Result := Length(Slots) <> Length(UsedSlots);
end;

function TThiever.HasSpace: Boolean;
begin
  if SuicideMode then //Makes sure we always have space to loot
  begin               //everything from the gravestone on suicide mode.
    if (Length(Self.LootArray) > 2) then
      Result := (Inventory.CountEmptySlots() > Self.GearAmount)
    else
      Result := (Inventory.CountEmptySlots() > Self.GearAmount) or
                (Inventory.ContainsItem(Self.CoinPouch) and
                 Inventory.ContainsItem('Coins')
                 and not Inventory.ContainsAny(Self.DropArray));
  end
  else
  begin
    if (Length(Self.LootArray) > 2) then
      Result := (Inventory.CountEmptySlots() >= 2) //if has things oher than coins
    else                                         //we need at least 2 spaces always.
      Result := (Inventory.CountEmptySlots() >= 2) or
                (Inventory.ContainsItem(Self.CoinPouch) and
                 Inventory.ContainsItem('Coins')
                 and not Inventory.ContainsAny(Self.DropArray));
  end;
end;


function TThiever.IsLowHP: Boolean;
var
  CurrentHP: Int32 := Minimap.GetHPLevel();
begin
  if NextHeal < 1 then
    NextHeal := Round(Antiban.GetUniqueNumber(Self.NPCMaxHit * 8));

  NextHeal += Random(-3, 3);

  Result := (CurrentHP <= NextHeal) or (CurrentHP <= Self.NPCMaxHit);
end;

function TThiever.IsPouchFull: Boolean;
begin
  if Self.CoinPouchLimit < 1 then
    Self.CoinPouchLimit := SRL.TruncatedGauss(28, 1);
  Result := Inventory.CountItemStack(Self.CoinPouch) >= Self.CoinPouchLimit;
end;


function TThiever.OpenCoinPouch(): Boolean;
var
  pouchCount, slot: Int32;
begin
  pouchCount := Inventory.CountItemStack(Self.CoinPouch);

  if not Inventory.FindItem(Self.CoinPouch, slot) then
    Exit;

  if Inventory.ClickSlot(slot) then
  begin
    Wait(300);
    Result := WaitUntil(not Inventory.ContainsItem(Self.CoinPouch), 100, 1200);
  end;

  if Result then
  begin
    Self.CoinPouchLimit := SRL.TruncatedGauss(28, 1);
    Self.TotalActions += pouchCount;
    WL.Activity.Restart();
  end;

  if not Result then
    Self.OpenCoinPouch();
end;

function TThiever.CheckFailed(StartingHP: Int32): Boolean;
var
  HasHitSplat: Boolean;
  CurrentHP: Int32 := Minimap.GetHPLevel();
begin
  HasHitSplat := not Self.RenderDisabled and
                (MainScreen.FindHitsplats(MainScreen.GetPlayerBox) <> []);

  Result := (CurrentHP < StartingHP) or HasHitSplat;

  if Result then
  begin
    if HasHitSplat then
    begin
      Options.RenderSelf;
      Self.RenderDisabled := True;
    end
    else
      Self.OpenCoinPouch();
  end;
end;

function TThiever.NecklaceExpired(): Boolean;
begin
  Result := Chat.FindMessage('crumbles', [CHAT_COLOR_LIGHT_RED]);
  Self.HasNeck := not Result;
end;

function TThiever.Dodged: Boolean;
begin
  Result := Chat.FindMessage('dodgy');
end;




function TThiever.Heal: Boolean;
begin
  repeat
    if not Inventory.Consume(FOOD_CONSUMABLE) then
      Exit;

    Wait(300, 500);
  until Result := (Minimap.GetHPPercent() >= (50 + Antiban.GetUniqueNumber(20)));

  if Result then
    NextHeal := Round(Antiban.GetUniqueNumber(Self.NPCMaxHit * 7));
end;

function TThiever.EquipNeck: Boolean;
begin
  if Result := Inventory.ClickItem(Self.Necklace) then Wait(300, 400);

  Self.FreshNeck := Self.HasNeck := Result;
end;

function TThiever.CheckNeck: Boolean;
begin
  Result := Self.HasNeck := Equipment.ContainsItem(Self.Necklace);

  Self.NeckTimer.Restart(Random(-30000, 60000));
end;


function TThiever.CastShadowVeil: Boolean;
begin
  if not Self.UseShadowVeil or not Magic.Open() then
    Exit;

  if not Magic.CanActivate(ERSSpell.SHADOW_VEIL) then
  begin
    Result := Self.UseShadowVeil := False;
    Exit(False);
  end;

  Result := Magic.CastSpell(ERSSpell.SHADOW_VEIL);
  Self.ShadowVeilTimer.Restart(Random(-5000, 5000));
end;

function TThiever.PickNPC: Boolean;
var
  Slot: Int32 := Inventory.GetSelectedSlot;
  CurrentHP: Int32 := Minimap.GetHPLevel();
begin
  if Slot > -1 then Inventory.ClickSlot(Slot);

  if Result := Self.CurrentNPC.SelectOption(['Pick', 'pocket']) then
  begin
    Minimap.WaitPlayerMoving(300, 10000);

    RSObjects.Gravestone.TileArray.Insert(Self.RSW.GetMyPos, 0);
    if Length(RSObjects.Gravestone.TileArray) > 4 then
      RSObjects.Gravestone.TileArray.Pop;

    if not Self.NecklaceExpired then
      Self.FreshNeck := False;

    Self.CheckFailed(CurrentHP);
    WL.Activity.Restart();
  end;
end;


function TThiever.Deposit: Boolean;
var
  ItemCount: Int32;
begin
  if ToStr(Self.ValuableItem) <> '' then
    ItemCount := Inventory.CountItem(Self.ValuableItem);
  Result := Bank.DepositAllBut(Self.BankTab, Self.StackableArray);
  if ItemCount > 0 then
  begin
    if Inventory.CountItem(Self.ValuableItem) = 0 then
      Self.TotalProfit += (ItemCount * Self.ValuableItemValue);
  end;
end;

function TThiever.Withdraw(Item: TRSItem; Quantity: Int32): Boolean;
var
  ItemCount: Int32 := Inventory.CountItem(Item);
  QuantityNeeded: Int32 := Quantity - ItemCount;
  InvCount: Int32;
begin
  InvCount := Inventory.Count();
  if Result := Bank.WithdrawItem(Self.BankTab, [Item, QuantityNeeded, False], False) then
    WaitUntil(Inventory.Count() > InvCount, 100, 3000);

  if not Result and (Item = Self.Necklace) and (PickedNPC = GUARD) then
    NeckAmount := 0;
end;

function TThiever.WithdrawAny(Items: TRSItemArray; Quantity: Int32): Boolean;
var
  Item: TRSItem;
  ItemCount: Int32 := Inventory.CountItems(Items);
  QuantityNeeded: Int32 := Quantity - ItemCount;
  InvCount: Int32;
begin
  for Item in Items do
    if Bank.ContainsItem(Item) then Exit(Self.Withdraw(Item, Quantity));

  for Item in Items do
  begin
    if Self.BankTab = -1 then
      Self.BankTab := Bank.FindItemTab(Item);

    InvCount := Inventory.Count();
    if Result := Bank.WithdrawItem(Self.BankTab, [Item, QuantityNeeded, False], False) then
    begin
      WaitUntil(Inventory.Count() > InvCount, 100, 3000);
      Exit;
    end;
  end;

  FoodHandler.Amount := 0;
end;

function TThiever.LootGrave: Boolean;
var
  TPA, GraveTPA: TPointArray;
  P: TPoint;
  UpTextFound: Boolean;
begin
  Self.HasNeck := False;
  Self.FreshNeck := False;
  Self.RedemptionEnabled := False;

  if not Minimap.WaitArrow(TPA, 3000) then
    Exit;

  while not MainScreen.WaitArrow(GraveTPA, 3000) do
  begin
    Mouse.Click(TPA.Grow(6).RandomValue(), MOUSE_LEFT);
    Minimap.WaitMoving();
  end;

  if not MainScreen.WaitArrow(GraveTPA, 3000) then
    Exit;

  repeat
    GraveTPA.SortByY(False);
    P := GraveTPA[0];
    P.Y += 5;
    Mouse.Move(P);
    UpTextFound := MainScreen.IsUpText('Grave');
    if not UpTextFound then
      MainScreen.WaitArrow(GraveTPA, 3000);
  until UpTextFound;

  Result := ChooseOption.Select('Loot');

  if Result then RSObjects.Gravestone.TileArray := [];
end;

function TThiever.EnableRedemption: Boolean;
begin
  Result := Prayer.ActivatePrayer(ERSPrayer.REDEMPTION);
  Self.UseRedemption := Self.RedemptionEnabled := Result;
end;


function TThiever.GetState(): EThieverState;
begin
  if WL.Activity.IsFinished() then
    Exit(END_SCRIPT);

  if ChooseOption.IsOpen() then
    Exit(CLOSE_CONTEXT);

  if MainScreen.FindGrave then
    Exit(LOOT_GRAVE);

  if MainScreen.HasInterface() then
  begin
    if Bank.IsOpen() then
    begin
      if Self.HasDepositItems then
        Exit(DEPOSIT_LOOT);
      if Inventory.CountItem(Self.Necklace) < NeckAmount then
        Exit(WITHDRAW_NECKLACES);
      if not Inventory.HasEnoughConsumable(FOOD_CONSUMABLE) then
        Exit(WITHDRAW_FOOD);
    end;

    Exit(CLOSE_INTERFACE);
  end;

  if Self.IsPouchFull then
    Exit(OPEN_POUCH);

  if ChatButtons.GetState(ERSChatButton.GAME_CHAT) <> ERSChatButtonState.ENABLED then
    Exit(CHANGE_CHAT_FILTER);

  if not ChatButtons.IsActive(ERSChatButton.GAME_CHAT) then
    Exit(OPEN_CHAT);

  if Self.NeckTimer.IsFinished() then
    Exit(CHECK_NECKLACE);

  if Self.HasRogue then
    Exit(EQUIP_ROGUE);

  if not Self.HasSpace then
  begin
    if Inventory.ContainsAny(Self.DropArray) then
      Exit(DROP_ITEMS);
    if Inventory.FindConsumable(FOOD_CONSUMABLE) then
      Exit(EAT_FOOD);

    Exit(OPEN_BANK);
  end;

  if (NeckAmount > 0) and not Self.FreshNeck and (not Self.HasNeck or Self.NecklaceExpired) then
  begin
    if Inventory.ContainsItem(Self.Necklace) then
      Exit(EQUIP_NECKLACE);

    Exit(OPEN_BANK);
  end;

  if Self.IsLowHP then
  begin
    if not Self.RedemptionEnabled and Inventory.FindConsumable(FOOD_CONSUMABLE) then
      Exit(EAT_FOOD);
    if not SuicideMode then
      Exit(OPEN_BANK);
    if not Self.RSW.AtTile(Self.CurrentNPC.TileArray, 40) then
      Exit(WALK_TO_NPC);
    if Self.UseRedemption and not Self.RedemptionEnabled then
      Exit(ENABLE_REDEMPTION);
    if Self.UseShadowVeil and Self.ShadowVeilTimer.IsFinished() then
      Exit(CAST_SHADOW_VEIL);

    Exit(PICKPOCKET);
  end;

  if not Self.RSW.AtTile(Self.CurrentNPC.TileArray, 40) then
    Exit(WALK_TO_NPC);

  if Self.UseShadowVeil and Self.ShadowVeilTimer.IsFinished() then
    Exit(CAST_SHADOW_VEIL);

  Exit(PICKPOCKET);
end;

procedure TThiever.Run(MaxActions: Int32; MaxTime: Int64);
begin
  ClearDebug();
  Self.Init(MaxActions, MaxTime);

  while not Self.ShouldStop do
  begin
    Self.State := Self.GetState();
    Self.SetAction(ToStr(Self.State));
    Self.ExtraInfo := ' FreshNeck: ' + ToStr(Self.FreshNeck) +
                 ',   HasNeck: ' + ToStr(Self.HasNeck) +
                 STR_NEW_LINE +
                  ' UseRedemption: ' + ToStr(Self.UseRedemption) +
                  ',   RedemptionEnabled: ' + ToStr(Self.RedemptionEnabled) +
                  ',   NextHeal: ' + ToStr(NextHeal) +
                  STR_NEW_LINE +
                  ' SuicideMode: ' + ToStr(SuicideMode) +
                  ',   UseShadowVeil: ' + ToStr(Self.UseShadowVeil);
    

    case Self.State of
      OPEN_BANK: Bank.WalkOpen(Self.ScriptBank);
      DEPOSIT_LOOT: Self.Deposit();
      WITHDRAW_FOOD: Bank.WithdrawConsumable(FOOD_CONSUMABLE);
      WITHDRAW_NECKLACES: Self.Withdraw(Self.Necklace, NeckAmount);
      CLOSE_INTERFACE: MainScreen.CloseInterface();

      OPEN_CHAT: ChatButtons.Open(ERSChatButton.GAME_CHAT);
      CHANGE_CHAT_FILTER: ChatButtons.ChangeState(ERSChatButton.GAME_CHAT, ERSChatButtonState.ENABLED);

      CAST_SHADOW_VEIL: Self.CastShadowVeil();
      PICKPOCKET: Self.PickNPC();
      OPEN_POUCH: Self.OpenCoinPouch();

      EAT_FOOD: Self.Heal();
      EQUIP_NECKLACE: Self.EquipNeck();
      CHECK_NECKLACE: Self.CheckNeck();
      CLOSE_CONTEXT: ChooseOption.Close();
      DROP_ITEMS: Inventory.ShiftDrop(Self.DropArray, Inventory.RandomPattern);
      WALK_TO_NPC: Self.RSW.WebWalk(Self.CurrentNPC.TileArray, 30, 0.2);
      EQUIP_ROGUE: Self.EquipRogue;
      LOOT_GRAVE: Self.LootGrave;
      ENABLE_REDEMPTION: Self.EnableRedemption;

      END_SCRIPT: Break;
    end;

    Self.DoAntiban();
  end;
end;

var
  Thiever: TThiever;


function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean; override;
begin
  Result := Self.CountPoints(ConsumableType) >= FoodHandler.Amount;
end;

type
  TThieverConfig = record(TScriptForm)
    NPCSelector: TLabeledCombobox;
    FoodAmountEdit: TLabeledEdit;
    NeckAmountEdit: TLabeledEdit;
    MinHealthEdit: TLabeledEdit;
    SuicideState: TCheckbox;
  end;

procedure TThieverConfig.StartScript(Sender: TObject);
begin
  Self.Init(Sender);

  PickedNPC := ENPC(Self.NPCSelector.Combobox.getItemIndex());
  SuicideMode := Self.SuicideState.getState = cbChecked;

  FoodAmount := StrToInt(Self.WLPanel.FoodPanel.ConsumableAmount.GetText());
  NeckAmount := StrToInt(Self.NeckAmountEdit.getText());
  NextHeal := StrToInt(Self.WLPanel.FoodPanel.MinPoints.GetText());
end;

procedure TThieverConfig.NPCSelectorOnChange(Sender: TObject);
begin
  Writeln(Sender, ' has changed');

  case ENPC(Self.NPCSelector.Combobox.getItemIndex()) of
    MAN:
      begin
        Self.SuicideState.setState(cbUnchecked);
        Self.SuicideState.setEnabled(False);
      end;

    MASTER_FARMER:
      begin
        Self.SuicideState.setState(cbUnchecked);
        Self.SuicideState.setEnabled(False);
      end;

    KNIGHT_OF_ARDOUGNE:
      begin
        Self.SuicideState.setState(cbUnchecked);
        Self.SuicideState.setEnabled(False);
      end;

    TZHAAR_CITY:
      begin
        Self.SuicideState.setState(cbUnchecked);
        Self.SuicideState.setEnabled(False);
      end;

    else
    begin
      Self.SuicideState.setState(cbChecked);
      Self.SuicideState.setEnabled(True);
    end;
  end;

end;

procedure TThieverConfig.Setup(UseFood, UsePrayer, UseBank: Boolean); override;
begin
  inherited;

  with Self.NPCSelector do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('NPC:');
    SetLeft(5);  
    SetTop(30);
    SetWidth(200);
    Combobox.setStyle(csDropDownList);
    Combobox.getItems.Add('Men and women (Lumbridge only)');
    Combobox.getItems.Add('Master farmers (Draynor only)');
    Combobox.getItems.Add('Guards (Falador only)');
    Combobox.getItems.Add('Knights of Ardougne');
    Combobox.getItems.Add('Elves (Prifddinas only)');
    Combobox.getItems.Add('Tzhaars');
    Combobox.setItemIndex(Ord(PickedNPC));
    Combobox.setOnChange(@Self.NPCSelectorOnChange);
  end;

  with Self.NeckAmountEdit do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Necklaces amount:');
    SetLeft(250);
    SetTop(30);
    SetWidth(110);
    SetText(ToStr(NeckAmount));
  end;

  with Self.SuicideState do
  begin
    Init(Self.SSPanel.Panel); 
    SetCaption('Suicide mode:');
    SetLeft(5);
    SetTop(15);
    SetEnabled(True);
    Self.NPCSelectorOnChange(@Self.SuicideState);
  end;

  Self.WLPanel.FoodPanel.ConsumableAmount.SetText(ToStr(FoodAmount));
  Self.WLPanel.FoodPanel.ConsumableAmount.SetVisible(True);
  Self.WLPanel.StartButton.setOnClick(@Self.StartScript);
end;

procedure TThieverConfig.Run(); override;
begin
  Self.Setup(True, False, False);

  inherited;
end;

var
  ThieverConfig: TThieverConfig;

begin
  {$IFDEF SCRIPT_GUI}
  Sync(@ThieverConfig.Run);
  {$ENDIF}
  Thiever.Run(MaxActions, MaxTime);
end.
